---
layout: default
title: "Kickstarter Goal Estimator"
permalink: /kickstarter/
body_classes: page-tools
---

<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Steam Tag Hunter</title>
  <link rel="stylesheet" href="styles.css" />

  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5TPPRZVDVF"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-5TPPRZVDVF');
  </script>
</head>

<body>
  <header class="site-header">
    <h1>Steam Tag Hunter</h1>
    <p class="sub">Find games based on tag similarity…</p>
  </header>

  <main class="container">
    <section class="controls controls-emphasis">
      <!-- Seed -->
      <div class="input-row">
        <input id="seedInput" class="input-main" type="text"
          placeholder="Paste a Steam URL, AppID, or EXACT game name…" />
        <button id="seedBtn" class="btn">Load tags</button>
      </div>
      <small id="seedStatus" class="meta" aria-live="polite"></small>

      <!-- Query tags -->
      <div class="input-row">
        <input id="tagInput" class="input-main" type="text" placeholder='e.g., FPS, Multiplayer, Cold War' />
        <button id="addBtn" class="btn btn-accent">Add tag(s)</button>
        <button id="clearBtn" class="btn btn-ghost">Clear tags</button>
      </div>
      <div id="activeTags" class="chips query-chips"></div>

      <!-- Banned tags -->
      <div class="input-row" style="margin-top:.4rem;">
        <input id="banInput" class="input-main" type="text" placeholder="Banned tags (comma-separated)" />
        <button id="banAddBtn" class="btn">Add banned</button>
        <button id="banClearBtn" class="btn btn-ghost">Clear banned</button>
      </div>
      <div class="banned-label">Games that contain any banned tag (within enabled pools) will be excluded.</div>
      <div id="bannedTags" class="chips banned-chips" style="margin-top:.25rem;"></div>

      <div class="options">
        <!-- 1) Scoring (kept, help made leaner) -->
        <fieldset>
          <legend>Scoring</legend>
          <label><input type="radio" name="scoreMode" value="containment" checked /> Containment</label>
          <label><input type="radio" name="scoreMode" value="jaccard" /> Jaccard</label>

          <div class="help-inline">
            <button type="button" class="btn btn-ghost btn-help" id="openScoreHelp">
              What’s the difference?
            </button>
          </div>

          <dialog id="scoreDialog" class="modal">
            <form method="dialog" class="modal__panel" aria-labelledby="scoreDlgTitle">
              <header class="modal__header">
                <h3 id="scoreDlgTitle">Scoring: Containment vs Jaccard</h3>
                <button class="modal__close" aria-label="Close scoring help">×</button>
              </header>

              <section class="modal__content">
                <div class="modal__intro">
                  Two ways to measure overlap between your query tags and a game’s tags:
                </div>

                <div class="modal__grid">
                  <article class="modal__card">
                    <div class="modal__cardHead">
                      <span class="badge badge-contain">Default</span>
                      <h4>Containment</h4>
                    </div>
                    <p class="eq">score = <strong>overlap</strong> ÷ <strong>your query size</strong></p>
                    <ul class="use-for">
                      <li>“Did it match the tags I care about?”</li>
                      <li>Extra tags on the game don’t hurt the score.</li>
                    </ul>

                    <div class="modal__example">
                      <div class="ex-row"><span class="ex-label">Your query</span><span class="chips-mini"><span
                            class="chip-mini match">roguelike</span><span
                            class="chip-mini match">deckbuilder</span><span class="chip-mini">pixel art</span></span>
                      </div>
                      <div class="ex-row"><span class="ex-label">Game</span><span class="chips-mini"><span
                            class="chip-mini match">roguelike</span><span
                            class="chip-mini match">deckbuilder</span><span class="chip-mini">strategy</span><span
                            class="chip-mini">indie</span></span></div>
                      <div class="ex-row ex-result">Overlap = 2 • Query size = 3 → <b>2/3 = 0.67</b></div>
                    </div>
                  </article>

                  <article class="modal__card">
                    <div class="modal__cardHead">
                      <span class="badge">Alt</span>
                      <h4>Jaccard</h4>
                    </div>
                    <p class="eq">score = <strong>overlap</strong> ÷ <strong>union</strong></p>
                    <ul class="use-for">
                      <li>Overall “vibe similarity.”</li>
                      <li>Unrelated extra tags reduce the score.</li>
                    </ul>

                    <div class="modal__example">
                      <div class="ex-row"><span class="ex-label">Your query</span><span class="chips-mini"><span
                            class="chip-mini match">roguelike</span><span
                            class="chip-mini match">deckbuilder</span><span class="chip-mini">pixel art</span></span>
                      </div>
                      <div class="ex-row"><span class="ex-label">Game</span><span class="chips-mini"><span
                            class="chip-mini match">roguelike</span><span
                            class="chip-mini match">deckbuilder</span><span class="chip-mini">strategy</span><span
                            class="chip-mini">indie</span></span></div>
                      <div class="ex-row ex-result">Overlap = 2 • Union = 5 → <b>2/5 = 0.40</b></div>
                    </div>
                  </article>
                </div>
              </section>

              <footer class="modal__footer">
                <button class="btn btn-accent">Got it</button>
              </footer>
            </form>
          </dialog>
        </fieldset>

        <!-- 2) Match (trimmed down to “what to compare” + strictness) -->
        <fieldset>
          <legend>Match</legend>
          <div class="toggle-row">
            <button type="button" class="toggle active" id="tTags" aria-pressed="true">Tags</button>
            <button type="button" class="toggle" id="tGenres" aria-pressed="false">Genres</button>
            <button type="button" class="toggle" id="tCategories" aria-pressed="false">Categories</button>
          </div>

          <label class="require-all"><input type="checkbox" id="requireAll" /> Require all query tags</label>


          <div class="toggle-row" style="margin-top:.25rem">
            <label class="require-all"><input type="checkbox" id="ignoreUnreleased" autocomplete="off" /> Hide
              unreleased</label>
          </div>

          <div class="date-filter">
            <label class="date-filter-label">
              <input type="checkbox" id="releaseFilterOn" autocomplete="off" />
              <span>Exclude games released before</span>
            </label>
            <select id="releaseMonth" aria-label="Release month"></select>
            <select id="releaseYear" aria-label="Release year"></select>
          </div>
        </fieldset>

        <!-- 3) Filters (split out of Match to reduce clutter) -->
        <fieldset>
          <legend>Filters</legend>
          <small class="meta">Leave blank to ignore a side. If any bound is set, unknown prices are excluded.</small>
          <div class="range-row">
            <label class="range-label">Price (USD)</label>
            <div class="range-inputs">
              <input id="priceMin" class="range-input" type="number" step="0.01" min="0" placeholder="min" />
              <span class="range-sep">–</span>
              <input id="priceMax" class="range-input" type="number" step="0.01" min="0" placeholder="max" />
            </div>
          </div>

          <div class="range-row">
            <label class="range-label">Estimated Revenue</label>
            <div class="range-inputs">
              <input id="revMin" class="range-input" type="number" step="1" min="0" placeholder="min" />
              <span class="range-sep">–</span>
              <input id="revMax" class="range-input" type="number" step="1" min="0" placeholder="max" />
            </div>
          </div>

        </fieldset>

        <!-- 4) View (beefed up) -->
        <fieldset>
          <legend>View</legend>
          <div class="toggle-row">
            <button type="button" class="toggle active" id="tThumbs" aria-pressed="true">Show thumbnails</button>
          </div>
        </fieldset>
      </div>

      </div>
    </section>

    <section id="results" class="results"></section>

    <div id="pager" class="pager" style="display:none;">
      <button id="prevBtn" class="btn btn-ghost" disabled>Prev</button>
      <span id="pageInfo" class="meta">Page 1 of 1</span>
      <button id="nextBtn" class="btn">Next</button>
    </div>
  </main>

  <script>
    // ---------- Config ----------
    const JSON_LINES_PATH = '/assets/games/games.compact.jsonl';
    const PAGE_SIZE = 10;

    // ---------- State ----------
    let games = [];
    let queryTags = new Set();
    let bannedTags = new Set();
    let useTags = true, useGenres = false, useCategories = false, showThumbs = true;


    let currentPage = 1;
    let lastResults = [];
    let totalPages = 1;

    // how many of the query tags actually exist in the enabled pools this render
    let requiredCount = 0;


    // always exclude the seed once set
    let seedExclude = null;

    const idx = { tags: new Map(), genres: new Map(), categories: new Map() };
    const byAppId = new Map();
    const byName = new Map();

    // ---------- Release-date filter ----------
    let releaseFilter = { on: false, y: null, m: null, cutoff: null };
    const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const firstOfMonthUTC = (y, m) => Date.UTC(y, m, 1);
    const fmtMonYear = ts => { const d = new Date(ts); return `${MONTHS[d.getUTCMonth()]} ${d.getUTCFullYear()}`; };
    function parseReleaseTs(raw) {
      if (!raw) return null;
      if (typeof raw === "number") return raw < 1e12 ? raw * 1000 : raw;
      if (typeof raw === "string") {
        const t = Date.parse(raw);
        if (!Number.isNaN(t)) return t;
        const m = raw.match(/^(\d{4})(?:-(\d{2}))?/);
        if (m) { const y = +m[1], mo = m[2] ? (+m[2] - 1) : 0; return Date.UTC(y, mo, 1); }
      }
      return null;
    }

    // ---------- DOM ----------
    const seedInput = document.getElementById('seedInput');
    const seedBtn = document.getElementById('seedBtn');
    const seedStatus = document.getElementById('seedStatus');

    const tagInput = document.getElementById('tagInput');
    const addBtn = document.getElementById('addBtn');
    const clearBtn = document.getElementById('clearBtn');
    const chipsEl = document.getElementById('activeTags');

    const banInput = document.getElementById('banInput');
    const banAddBtn = document.getElementById('banAddBtn');
    const banClearBtn = document.getElementById('banClearBtn');
    const bannedEl = document.getElementById('bannedTags');

    const resultsEl = document.getElementById('results');
    const scoreModeEls = document.querySelectorAll('input[name="scoreMode"]');
    const requireAllEl = document.getElementById('requireAll');
    const tTagsBtn = document.getElementById('tTags');
    const tGenresBtn = document.getElementById('tGenres');
    const tCategoriesBtn = document.getElementById('tCategories');


    const priceMinEl = document.getElementById('priceMin');
    const priceMaxEl = document.getElementById('priceMax');
    const revMinEl = document.getElementById('revMin');
    const revMaxEl = document.getElementById('revMax');

    const openScoreHelpBtn = document.getElementById('openScoreHelp');
    const scoreDialog = document.getElementById('scoreDialog');



    const releaseFilterOn = document.getElementById('releaseFilterOn');
    const releaseMonthSel = document.getElementById('releaseMonth');
    const releaseYearSel = document.getElementById('releaseYear');
    const ignoreUnreleasedEl = document.getElementById('ignoreUnreleased');

    const pagerEl = document.getElementById('pager');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const pageInfoEl = document.getElementById('pageInfo');

    // Force sane defaults on initial load (browsers may restore form/button state)
    useTags = true;
    tTagsBtn.classList.add('active');
    tTagsBtn.setAttribute('aria-pressed', 'true');


    // Do NOT hide unreleased by default
    if (ignoreUnreleasedEl) ignoreUnreleasedEl.checked = false;

    // Date filter OFF by default (critical for unreleased UX)
    if (releaseFilterOn) {
      releaseFilterOn.checked = false;  // checkbox state
      releaseFilter.on = false;         // internal state
    }



    // ---------- Utils ----------
    const normTag = t => t.trim().toLowerCase();
    const normName = s => (s || '').trim().toLowerCase();

    // Scoring help modal
    if (openScoreHelpBtn && scoreDialog) {
      openScoreHelpBtn.addEventListener('click', () => {
        if (typeof scoreDialog.showModal === 'function') scoreDialog.showModal();
        else scoreDialog.setAttribute('open', ''); // fallbacks
      });

      scoreDialog.addEventListener('click', (e) => {
        // click outside panel closes (backdrop click)
        const rect = scoreDialog.querySelector('.modal__panel').getBoundingClientRect();
        const within = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
        if (!within) scoreDialog.close();
      });

      scoreDialog.querySelector('.modal__close').addEventListener('click', () => scoreDialog.close());
      scoreDialog.addEventListener('keydown', (e) => { if (e.key === 'Escape') scoreDialog.close(); });
    }


    // price helpers (null price ≠ free)
    const isFreeGame = g => (g.is_free === true) || (g.price === 0);
    const formatPrice = p => (p == null) ? '—' : (p === 0 ? 'Free' : `$${Number(p).toFixed(2)}`);
    const estimateSalesUSD = g => {
      const r = g.reviews ?? 0;
      const p = isFreeGame(g) ? 0 : (g.price ?? 0);
      return (r > 0 && p > 0) ? r * p * 20 : 0;
    };
    const formatUSD = n => n ? n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }) : '—';

    function decileLabel(pct) {
      if (pct === 100) return 'exact match';
      const d = Math.floor(pct / 10) * 10;
      return ({
        90: 'almost exact', 80: 'highly similar', 70: 'very similar', 60: 'pretty similar',
        50: 'moderately similar', 40: 'somewhat similar', 30: 'loose match', 20: 'very weak match', 10: 'barely related'
      }[d]) || 'no real match';
    }
    const similarityColor = pct => `hsl(${Math.round((pct / 100) * 120)} 80% 55%)`;

    const readNum = el => {
      if (!el) return null;
      const v = (el.value ?? '').trim();
      if (v === '') return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };


    // ---------- Indexing ----------
    function addPosting(map, tag, gi) { if (!map.has(tag)) map.set(tag, []); map.get(tag).push(gi); }
    function buildIndices() {
      for (let gi = 0; gi < games.length; gi++) {
        const g = games[gi];
        (g.tags || []).forEach(t => addPosting(idx.tags, t, gi));
        (g.genres || []).forEach(t => addPosting(idx.genres, t, gi));
        (g.categories || []).forEach(t => addPosting(idx.categories, t, gi));
      }
      for (const map of [idx.tags, idx.genres, idx.categories]) {
        for (const [k, arr] of map.entries()) arr.sort((a, b) => a - b);
      }
    }
    function buildLookups() {
      for (let gi = 0; gi < games.length; gi++) {
        const g = games[gi];
        byAppId.set(String(g.app_id), gi);
        const nm = normName(g.name);
        if (!byName.has(nm)) byName.set(nm, []);
        byName.get(nm).push(gi);
      }
    }
    function postingsFor(tag, pools) {
      let out = [];
      for (const p of pools) {
        const arr = idx[p].get(tag) || [];
        if (out.length === 0) { out = out.concat(arr); continue; }
        let i = 0, j = 0, res = [], a = out, b = arr, last = null;
        while (i < a.length || j < b.length) {
          const va = i < a.length ? a[i] : Infinity;
          const vb = j < b.length ? b[j] : Infinity;
          let v;
          if (va < vb) { v = va; i++; }
          else if (vb < va) { v = vb; j++; }
          else { v = va; i++; j++; }
          if (v !== last) { res.push(v); last = v; }
        }
        out = res;
      }
      return out;
    }
    function intersectSorted(a, b) {
      const res = []; let i = 0, j = 0;
      while (i < a.length && j < b.length) {
        if (a[i] === b[j]) { res.push(a[i]); i++; j++; }
        else if (a[i] < b[j]) i++; else j++;
      }
      return res;
    }

    // ---------- Scoring ----------
    function buildTagSetFromPools(g, pools) {
      const s = new Set();
      if (pools.includes('tags')) (g.tags || []).forEach(t => s.add(t));
      if (pools.includes('genres')) (g.genres || []).forEach(t => s.add(t));
      if (pools.includes('categories')) (g.categories || []).forEach(t => s.add(t));
      return s;
    }
    function hasAnyBanned(g, pools) {
      if (bannedTags.size === 0) return false;
      const s = buildTagSetFromPools(g, pools);
      for (const bt of bannedTags) if (s.has(bt)) return true;
      return false;
    }
    function similarityScore(g, qSet, mode, pools) {
      const gSet = buildTagSetFromPools(g, pools);
      let inter = 0;
      for (const t of qSet) if (gSet.has(t)) inter++;

      const containsAll = inter === qSet.size;
      const exactOnly = containsAll && gSet.size === qSet.size;

      if (inter === 0) return { score: 0, inter, gSize: gSet.size, containsAll, exactOnly };

      const score = (mode === 'containment')
        ? inter / Math.max(1, qSet.size)
        : inter / Math.max(1, new Set([...qSet, ...gSet]).size);

      return { score, inter, gSize: gSet.size, containsAll, exactOnly };
    }


    // ---------- UI ----------
    function renderChips() {
      // Query chips
      chipsEl.innerHTML = '';
      if (queryTags.size === 0) {
        chipsEl.innerHTML = '<div class="hint">No active tags. Add some to see results.</div>';
      } else {
        for (const t of queryTags) {
          const chip = document.createElement('span'); chip.className = 'chip chip-query'; chip.textContent = t;
          const x = document.createElement('button'); x.className = 'chip-x'; x.type = 'button';
          x.setAttribute('aria-label', `Remove ${t}`); x.textContent = '×';
          x.onclick = (e) => { e.stopPropagation(); queryTags.delete(t); currentPage = 1; renderChips(); renderQuery(); };
          chip.appendChild(x); chipsEl.appendChild(chip);
        }
      }

      // Banned chips
      bannedEl.innerHTML = '';
      for (const t of bannedTags) {
        const chip = document.createElement('span'); chip.className = 'chip'; chip.textContent = t;
        const x = document.createElement('button'); x.className = 'chip-x'; x.type = 'button';
        x.setAttribute('aria-label', `Remove ${t}`); x.textContent = '×';
        x.onclick = (e) => { e.stopPropagation(); bannedTags.delete(t); currentPage = 1; renderChips(); renderQuery(); };
        chip.appendChild(x); bannedEl.appendChild(chip);
      }
    }

    function highlightTag(tag, q) {
      const s = document.createElement('span');
      s.className = q.has(tag) ? 'tag matched' : 'tag';
      s.textContent = tag;
      return s;
    }

    function renderPage() {
      resultsEl.innerHTML = '';
      const start = (currentPage - 1) * PAGE_SIZE;
      const slice = lastResults.slice(start, start + PAGE_SIZE);

      // Keep full query for highlighting matched vs not
      const q = new Set(queryTags);

      for (const item of slice) {
        const g = games[item.gIdx];
        const pct = Math.round(item.score * 100);
        const color = similarityColor(pct);
        const label = decileLabel(pct);

        const card = document.createElement('article');
        card.className = 'card';
        if (!showThumbs) card.classList.add('minimal');

        // Header
        const header = document.createElement('div'); header.className = 'card-header';
        if (showThumbs && g.header) {
          const img = document.createElement('img'); img.className = 'thumb thumb-inline';
          img.loading = 'lazy'; img.decoding = 'async'; img.alt = `${g.name} header image`; img.src = g.header;
          header.appendChild(img);
        }
        const title = document.createElement('h3'); title.className = 'title';
        const a = document.createElement('a'); a.href = `https://store.steampowered.com/app/${g.app_id}`; a.target = '_blank'; a.rel = 'noopener noreferrer'; a.textContent = g.name;
        title.appendChild(a); header.appendChild(title);

        const pill = document.createElement('span'); pill.className = 'sim-pill';
        // Use requiredCount (effective query size for current pools) in the tooltip
        pill.title = `Matched ${item.interCount} of ${requiredCount} required tag(s) • ${label}`;
        pill.textContent = `${pct}%`; pill.style.borderColor = color; pill.style.color = color;
        header.appendChild(pill);
        card.appendChild(header);

        // Meta row
        const devs = (g.developers && g.developers.length) ? g.developers.join(', ') : '—';
        const pubs = (g.publishers && g.publishers.length) ? g.publishers.join(', ') : '—';
        const estimate = estimateSalesUSD(g);

        const meta = document.createElement('div'); meta.className = 'meta-row';
        meta.innerHTML = `
      <span class="meta">Developer: ${devs}</span>
      <span class="meta">Publisher: ${pubs}</span>
      <span class="meta">Released: ${g.comingSoon ? 'Coming soon' : (g.releaseFmt ?? '—')}</span>
      <span class="meta">Price: ${formatPrice(g.price)}</span>
      <span class="meta">Reviews: ${(g.reviews || 0).toLocaleString()}</span>
      <span class="meta" title="Estimated = reviews × price × 20">Estimated Sales: ${formatUSD(estimate)}</span>
    `;
        card.appendChild(meta);

        // Similarity bar
        const barWrap = document.createElement('div'); barWrap.className = 'bar-wrap';
        const bar = document.createElement('div'); bar.className = 'bar'; bar.style.width = pct + '%'; bar.style.background = color;
        barWrap.appendChild(bar); card.appendChild(barWrap);

        // Tags
        const tagsDiv = document.createElement('div'); tagsDiv.className = 'tags';
        const pools = [];
        if (useTags) pools.push('tags');
        if (useGenres) pools.push('genres');
        if (useCategories) pools.push('categories');

        const show = [];
        if (pools.includes('tags')) show.push(...(g.tags || []));
        if (pools.includes('genres')) show.push(...(g.genres || []));
        if (pools.includes('categories')) show.push(...(g.categories || []));

        show.forEach(t => {
          const s = document.createElement('span');
          s.className = q.has(t) ? 'tag matched' : 'tag';
          s.textContent = t;
          tagsDiv.appendChild(s);
        });
        card.appendChild(tagsDiv);

        resultsEl.appendChild(card);
      }

      pageInfoEl.textContent = `Page ${currentPage} of ${totalPages}`;
      prevBtn.disabled = currentPage <= 1;
      nextBtn.disabled = currentPage >= totalPages;
      pagerEl.style.display = totalPages > 1 ? '' : (queryTags.size ? '' : 'none');
    }


    function renderQuery() {
      const hideUnreleased = !!(ignoreUnreleasedEl && ignoreUnreleasedEl.checked);
      const dateOn = !!(releaseFilterOn && releaseFilterOn.checked);
      releaseFilter.on = dateOn;

      const q = new Set(queryTags);
      if (q.size === 0) { resultsEl.innerHTML = ''; pagerEl.style.display = 'none'; return; }

      const pools = [];
      if (useTags) pools.push('tags');
      if (useGenres) pools.push('genres');
      if (useCategories) pools.push('categories');

      if (pools.length === 0) {
        resultsEl.innerHTML = '<div class="card">Enable at least one pool (Tags / Genres / Categories).</div>';
        pagerEl.style.display = 'none';
        return;
      }

      const tags = [...q];
      const lists = tags.map(t => ({ tag: t, docs: postingsFor(t, pools) }));
      const nonEmpty = lists.filter(x => x.docs.length > 0);

      if (nonEmpty.length === 0) {
        resultsEl.innerHTML = `
      <div class="card">
        None of your query tags exist in the enabled pools (${pools.join(', ') || '—'}).
        Try enabling a different pool or adjust your tags.
      </div>`;
        pagerEl.style.display = 'none';
        return;
      }

      const qEff = new Set(nonEmpty.map(x => x.tag));
      requiredCount = qEff.size;

      const requireAll = !!(requireAllEl && requireAllEl.checked);

      // candidate set (union vs intersection) is just a prefilter; exactness is enforced later
      nonEmpty.sort((a, b) => a.docs.length - b.docs.length);
      let candidates = nonEmpty[0].docs.slice();

      const union = (a, b) => {
        const out = []; let i = 0, j = 0, last = null;
        while (i < a.length || j < b.length) {
          const va = i < a.length ? a[i] : Infinity;
          const vb = j < b.length ? b[j] : Infinity;
          let v;
          if (va < vb) { v = va; i++; }
          else if (vb < va) { v = vb; j++; }
          else { v = va; i++; j++; }
          if (v !== last) { out.push(v); last = v; }
        }
        return out;
      };

      for (let i = 1; i < nonEmpty.length; i++) {
        candidates = requireAll
          ? intersectSorted(candidates, nonEmpty[i].docs)
          : union(candidates, nonEmpty[i].docs);
        if (requireAll && candidates.length === 0) break;
      }

      const mode = [...scoreModeEls].find(r => r.checked)?.value || 'containment';
      const results = [];

      for (const gi of candidates) {
        const g = games[gi];

        if (seedExclude && (String(g.app_id) === seedExclude.app_id || normName(g.name) === seedExclude.name)) continue;
        if (hideUnreleased && g.comingSoon) continue;

        if (dateOn && !g.comingSoon) {
          if (!(typeof g.releaseTs === 'number')) continue;
          if (g.releaseTs < releaseFilter.cutoff) continue;
        }

        if (hasAnyBanned(g, pools)) continue;

        const pMin = readNum(priceMinEl), pMax = readNum(priceMaxEl);
        if (pMin !== null || pMax !== null) {
          const price = g.price;
          if (price == null) continue;
          if (pMin !== null && price < pMin) continue;
          if (pMax !== null && price > pMax) continue;
        }

        const rMin = readNum(revMinEl), rMax = readNum(revMaxEl);
        if (rMin !== null || rMax !== null) {
          const rev = estimateSalesUSD(g);
          if (!Number.isFinite(rev) || rev <= 0) continue;
          if (rMin !== null && rev < rMin) continue;
          if (rMax !== null && rev > rMax) continue;
        }

        // --- core fix: "Require all" means EXACT tag set in enabled pools ---
        const sc = similarityScore(g, qEff, mode, pools);
        if (requireAll) {
          if (!sc.exactOnly) continue; // must contain all AND have no extra tags (in enabled pools)
        } else {
          if (sc.score <= 0) continue;
        }

        results.push({ gIdx: gi, score: sc.score, interCount: sc.inter });
      }

      results.sort((a, b) => {
        const ga = games[a.gIdx], gb = games[b.gIdx];
        if (b.score !== a.score) return b.score - a.score;
        const ar = ga.reviews || 0, br = gb.reviews || 0;
        if (br !== ar) return br - ar;
        const at = ga.releaseTs || 0, bt = gb.releaseTs || 0;
        if (bt !== at) return bt - at;
        const aSoon = !!ga.comingSoon, bSoon = !!gb.comingSoon;
        if (aSoon !== bSoon) return aSoon ? 1 : -1;
        return normName(ga.name).localeCompare(normName(gb.name));
      });

      const seen = new Set();
      lastResults = results.filter(r => {
        const g = games[r.gIdx];
        const key = `${normName(g.name)}::${g.comingSoon ? 'soon' : 'released'}`;
        if (seen.has(key)) return false;
        seen.add(key); return true;
      });

      totalPages = Math.max(1, Math.ceil(lastResults.length / PAGE_SIZE));
      currentPage = Math.min(currentPage, totalPages);
      renderPage();
    }



    // ---------- Seed ----------
    function parseSeedToAppId(str) {
      const s = (str || '').trim(); if (!s) return null;
      if (/^\d+$/.test(s)) return s;
      const m = s.match(/store\.steampowered\.com\/app\/(\d+)/i); if (m) return m[1];
      return null;
    }
    function findGameBySeed(seedRaw) {
      const appId = parseSeedToAppId(seedRaw);
      if (appId) { if (byAppId.has(String(appId))) return games[byAppId.get(String(appId))]; return null; }
      const nm = normName(seedRaw); if (!nm) return null;
      const arr = byName.get(nm); if (!arr || arr.length === 0) return null;
      const bestGi = arr.slice().sort((a, b) => (games[b].reviews || 0) - (games[a].reviews || 0))[0];
      return games[bestGi];
    }
    function injectTagsFromGame(g) {
      const pools = []; if (useTags) pools.push('tags'); if (useGenres) pools.push('genres'); if (useCategories) pools.push('categories');
      const incoming = []; if (pools.includes('tags')) incoming.push(...(g.tags || []));
      if (pools.includes('genres')) incoming.push(...(g.genres || []));
      if (pools.includes('categories')) incoming.push(...(g.categories || []));
      let added = 0;
      for (const t of incoming) {
        const nt = normTag(t);
        const before = queryTags.size; queryTags.add(nt);
        if (queryTags.size > before) added++;
      }
      return { added, total: incoming.length };
    }
    function handleSeed() {
      seedStatus.textContent = '';
      const raw = seedInput.value.trim();
      if (!raw) { seedStatus.textContent = 'Enter a Steam URL, AppID, or exact game name.'; return; }
      const g = findGameBySeed(raw);
      if (!g) { seedStatus.textContent = 'That game isn’t in this list.'; return; }
      const { added, total } = injectTagsFromGame(g);
      seedExclude = { app_id: String(g.app_id), name: normName(g.name) }; // always exclude itself
      seedStatus.textContent = `Loaded ${added}/${total} tag(s) from “${g.name}”. (Excluded itself from results)`;
      currentPage = 1; renderChips(); renderQuery();
    }

    // ---------- Events ----------
    function parseFreeformTags(str) {
      const parts = str.split(/,/).map(s => s.trim()).filter(Boolean);
      return parts.map(p => normTag(p.replace(/^["'](.*)["']$/s, '$1')));
    }
    seedBtn.addEventListener('click', handleSeed);
    seedInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); handleSeed(); } });

    tagInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        parseFreeformTags(tagInput.value).forEach(t => queryTags.add(t));
        tagInput.value = ''; currentPage = 1; renderChips(); renderQuery();
      }
    });
    addBtn.onclick = () => { parseFreeformTags(tagInput.value).forEach(t => queryTags.add(t)); tagInput.value = ''; currentPage = 1; renderChips(); renderQuery(); };
    clearBtn.onclick = () => { queryTags.clear(); currentPage = 1; renderChips(); renderQuery(); };

    banInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        parseFreeformTags(banInput.value).forEach(t => bannedTags.add(t));
        banInput.value = ''; currentPage = 1; renderChips(); renderQuery();
      }
    });
    banAddBtn.onclick = () => { parseFreeformTags(banInput.value).forEach(t => bannedTags.add(t)); banInput.value = ''; currentPage = 1; renderChips(); renderQuery(); };
    banClearBtn.onclick = () => { bannedTags.clear(); currentPage = 1; renderChips(); renderQuery(); };

    [...scoreModeEls].forEach(el => el.addEventListener('change', () => { currentPage = 1; renderQuery(); }));
    if (requireAllEl) {
      requireAllEl.addEventListener('change', () => { currentPage = 1; renderQuery(); });
    }

    const requireAllHint = document.getElementById('requireAllHint');
    if (requireAllEl && requireAllHint) {
      requireAllEl.addEventListener('change', () => {
        requireAllHint.style.display = requireAllEl.checked ? '' : 'none';
      });
      // reflect initial state
      requireAllHint.style.display = requireAllEl.checked ? '' : 'none';
    }


    function toggleButton(btn, setter) {
      const active = btn.classList.toggle('active');
      btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      setter(active); currentPage = 1; renderQuery();
    }
    tTagsBtn.addEventListener('click', () => toggleButton(tTagsBtn, v => useTags = v));
    tGenresBtn.addEventListener('click', () => toggleButton(tGenresBtn, v => useGenres = v));
    tCategoriesBtn.addEventListener('click', () => toggleButton(tCategoriesBtn, v => useCategories = v));

    const tThumbsBtn = document.getElementById('tThumbs');
    const tCompactBtn = document.getElementById('tCompact'); // NEW

    tThumbsBtn.addEventListener('click', () => toggleButton(tThumbsBtn, v => showThumbs = v));
    tCompactBtn?.addEventListener('click', () =>
      toggleButton(tCompactBtn, v => {
        document.body.classList.toggle('compact-mode', v);
      })
    );



    prevBtn.addEventListener('click', () => { if (currentPage > 1) { currentPage--; renderPage(); } });
    nextBtn.addEventListener('click', () => { if (currentPage < totalPages) { currentPage++; renderPage(); } });

    [priceMinEl, priceMaxEl, revMinEl, revMaxEl].forEach(el => {
      if (!el) return;
      el.addEventListener('input', () => { currentPage = 1; renderQuery(); });
      el.addEventListener('change', () => { currentPage = 1; renderQuery(); });
    });


    // ---------- Load ----------
    (async () => {
      try {
        const res = await fetch(JSON_LINES_PATH, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Could not load ${JSON_LINES_PATH}`);
        const text = await res.text(); // keep only this one

        function parseRow(line) {
          const j = JSON.parse(line);
          const arr = v => Array.isArray(v) ? v : (v ? [v] : []);

          // Compact schema: {a,n,d,p,u,f,r,y,cs,h,t}
          if (Object.prototype.hasOwnProperty.call(j, 'a')) {
            const y = (typeof j.y === 'number' && j.y > 0) ? j.y : null;
            const relTs = y != null ? Date.UTC(y, 0, 1) : null;
            return {
              app_id: j.a,
              name: j.n || `App ${j.a}`,
              tags: arr(j.t).map(t => (t ?? '').trim().toLowerCase()),
              genres: [],
              categories: [],
              developers: arr(j.d),
              publishers: arr(j.p),
              price: j.u ?? null,
              is_free: !!j.f,
              reviews: j.r ?? 0,
              header: j.h || null,
              releaseTs: relTs,
              releaseFmt: relTs ? fmtMonYear(relTs) : (y ? String(y) : null),
              comingSoon: !!j.cs
            };
          }

          // Verbose fallback
          const cls = j.classification || {};
          const id = j.identity || {};
          const media = j.media || {};
          const relRaw =
            j.release?.date_iso ??
            j.release?.date_raw ??
            id.release_date ??
            j.release_date ??
            j.meta?.release_date;

          const relTs = parseReleaseTs(relRaw);

          return {
            app_id: j.app_id,
            name: id.name || `App ${j.app_id}`,
            tags: arr(cls.tags).map(t => (t ?? '').trim().toLowerCase()),
            genres: arr(cls.genres).map(t => (t ?? '').trim().toLowerCase()),
            categories: arr(cls.categories).map(t => (t ?? '').trim().toLowerCase()),
            developers: arr(id.developers),
            publishers: arr(id.publishers),
            price: j.pricing ? j.pricing.price_usd : null,
            is_free: !!(j.pricing && j.pricing.is_free),
            reviews: (j.reviews?.review_count) ?? (j.reviews?.total_reviews) ?? 0,
            header: media.header_image || null,
            releaseTs: relTs,
            releaseFmt: relTs ? fmtMonYear(relTs) : null,
            comingSoon: !!(j.release && j.release.coming_soon)
          };
        }

        games = text
          .split(/\r?\n/)
          .map(l => l.trim())
          .filter(Boolean)
          .map(parseRow);

        buildIndices();
        buildLookups();


        // Populate release selects
        const yearsInData = games.map(g => g.releaseTs).filter(Boolean).map(ts => new Date(ts).getUTCFullYear());
        const minYear = yearsInData.length ? Math.min(...yearsInData) : 1997;
        const maxYear = yearsInData.length ? Math.max(...yearsInData) : (new Date()).getUTCFullYear();

        releaseMonthSel.innerHTML = MONTHS.map((m, i) => `<option value="${i}">${m}</option>`).join('');
        let yOpts = ''; for (let y = maxYear; y >= minYear; y--) yOpts += `<option value="${y}">${y}</option>`;
        releaseYearSel.innerHTML = yOpts;

        releaseMonthSel.value = String((new Date()).getUTCMonth());
        releaseYearSel.value = String((new Date()).getUTCFullYear());

        function updateReleaseCutoff() {
          const y = +releaseYearSel.value, m = +releaseMonthSel.value;
          releaseFilter.y = y; releaseFilter.m = m; releaseFilter.cutoff = firstOfMonthUTC(y, m);
          currentPage = 1; renderQuery();
        }

        releaseFilterOn.addEventListener('change', () => {
          // Trust the checkbox; render will re-sync too
          if (releaseFilterOn.checked) {
            updateReleaseCutoff();
          } else {
            releaseFilter.on = false; // explicit
            currentPage = 1;
            renderQuery();
          }
        });

        // Only recompute cutoff if the feature is ON
        releaseMonthSel.addEventListener('change', () => {
          if (releaseFilterOn && releaseFilterOn.checked) updateReleaseCutoff();
        });
        releaseYearSel.addEventListener('change', () => {
          if (releaseFilterOn && releaseFilterOn.checked) updateReleaseCutoff();
        });


        if (ignoreUnreleasedEl) {
          ignoreUnreleasedEl.addEventListener('change', () => { currentPage = 1; renderQuery(); });
        }

      } catch (err) {
        resultsEl.innerHTML = `<div class="card">${err.message}</div>`;
        return;
      }
      renderChips(); // wait for user query
    })();
  </script>
</body>

</html>