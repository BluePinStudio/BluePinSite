<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Steam Tag Hunter</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* small inline tweaks that won't fight your stylesheet */

    /* Pager */
    .pager {
      display: flex;
      align-items: center;
      gap: .6rem;
      justify-content: center;
      margin: 1rem 0 2rem;
    }

    .pager .meta {
      opacity: .85
    }

    .btn[disabled] {
      opacity: .5;
      cursor: not-allowed
    }

    /* Banned chip tint */
    .banned-chips .chip {
      border-color: color-mix(in srgb, #ff6b6b 50%, var(--chip-border));
      background: color-mix(in srgb, #ff6b6b 12%, var(--chip));
    }

    /* Compact seed status */
    #seedStatus {
      display: block;
      margin: .2rem 0 .3rem;
      min-height: 1rem;
    }

    /* Compact header row */
    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: .8rem;
      margin-bottom: .4rem;
    }

    .card-header .title {
      flex: 1;
      font-size: 1.05rem;
      margin: 0;
    }

    .sim-pill {
      font-size: .85rem;
      padding: .2rem .5rem;
      border-radius: 6px;
      border: 1px solid currentColor;
      white-space: nowrap;
    }

    /* Inline thumbnail (larger) */
    .thumb-inline {
      width: 160px;
      height: auto;
      border-radius: 8px;
      border: 1px solid var(--chip-border);
      box-shadow: 0 2px 8px rgba(0, 0, 0, .3);
      object-fit: cover;
    }

    /* Date filter */
    .date-filter {
      display: flex;
      align-items: center;
      gap: .4rem;
      margin: .2rem 0 0;
    }

    .date-filter-label {
      display: inline-flex;
      align-items: center;
      gap: .35rem;
      margin-right: .25rem;
      white-space: nowrap;
    }

    #releaseMonth,
    #releaseYear {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--outline);
      border-radius: 8px;
      padding: .35rem .5rem;
      font-size: .9rem;
    }

    /* Help panel polish */
    details.help {
      margin-top: .35rem;
    }

    .help-body {
      padding: .6rem .75rem .8rem;
      background: var(--bg-elev);
      border: 1px solid var(--outline);
      border-radius: 12px;
    }

    .help-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: .6rem;
    }

    .help-card {
      background: var(--card);
      border: 1px solid var(--outline);
      border-radius: 12px;
      padding: .6rem .75rem;
    }

    .help-head {
      display: flex;
      align-items: center;
      gap: .5rem;
      margin-bottom: .25rem;
    }

    .badge {
      font-size: .75rem;
      border: 1px solid var(--outline);
      padding: .05rem .4rem;
      border-radius: 999px;
      opacity: .85;
    }

    .badge-contain {
      background: color-mix(in srgb, var(--accent) 16%, transparent);
      border-color: color-mix(in srgb, var(--accent) 40%, var(--outline));
    }

    .eq {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      opacity: .9;
    }
  </style>
</head>

<body>
  <header class="site-header">
    <h1>Steam Tag Hunter</h1>
    <p class="sub">Find games based on tag similarity…</p>
  </header>

  <main class="container">
    <section class="controls controls-emphasis">
      <!-- Seed -->
      <div class="input-row">
        <input id="seedInput" class="input-main" type="text"
          placeholder="Paste a Steam URL, AppID, or EXACT game name…" />
        <button id="seedBtn" class="btn">Load tags</button>
      </div>
      <small id="seedStatus" class="meta" aria-live="polite"></small>

      <!-- Query tags -->
      <div class="input-row">
        <input id="tagInput" class="input-main" type="text" placeholder='e.g., FPS, Multiplayer, Cold War' />
        <button id="addBtn" class="btn btn-accent">Add tag(s)</button>
        <button id="clearBtn" class="btn btn-ghost">Clear tags</button>
      </div>
      <div id="activeTags" class="chips query-chips"></div>

      <!-- Banned tags -->
      <div class="input-row" style="margin-top:.4rem;">
        <input id="banInput" class="input-main" type="text" placeholder="Banned tags (comma-separated)" />
        <button id="banAddBtn" class="btn">Add banned</button>
        <button id="banClearBtn" class="btn btn-ghost">Clear banned</button>
      </div>
      <div class="banned-label">Games that contain any banned tag (within enabled pools) will be excluded.</div>
      <div id="bannedTags" class="chips banned-chips" style="margin-top:.25rem;"></div>

      <!-- Options -->
      <div class="options">
        <fieldset>
          <legend>Scoring</legend>
          <label><input type="radio" name="scoreMode" value="containment" checked /> Containment</label>
          <label><input type="radio" name="scoreMode" value="jaccard" /> Jaccard</label>

          <details class="help">
            <summary>What’s the difference?</summary>
            <div class="help-body">
              <div class="help-grid">
                <div class="help-card">
                  <div class="help-head">
                    <span class="badge badge-contain">Default</span>
                    <h4>Containment</h4>
                  </div>
                  <div class="eq">overlap ÷ <strong>your query size</strong></div>
                  <p class="muted">Measures how much of your request is covered. Ignores extra tags the game has.</p>
                </div>
                <div class="help-card">
                  <div class="help-head">
                    <span class="badge">Alt</span>
                    <h4>Jaccard</h4>
                  </div>
                  <div class="eq">overlap ÷ <strong>union</strong></div>
                  <p class="muted">Measures overall vibe. Penalizes extra, unrelated tags on the game.</p>
                </div>
              </div>
            </div>
          </details>
        </fieldset>

        <fieldset>
          <legend>Match Options</legend>
          <div class="toggle-row">
            <button type="button" class="toggle active" id="tTags" aria-pressed="true">Include Tags</button>
            <button type="button" class="toggle" id="tGenres" aria-pressed="false">Include Genres</button>
            <button type="button" class="toggle" id="tCategories" aria-pressed="false">Include Categories</button>
          </div>

          <label class="require-all"><input type="checkbox" id="requireAll" /> Require all query tags</label>
          <label class="require-all"><input type="checkbox" id="ignoreUnreleased" autocomplete="off" /> Hide unreleased
            (Coming
            soon)</label>

          <!-- Release date filter -->
          <div class="date-filter">
            <label class="date-filter-label">
              <input type="checkbox" id="releaseFilterOn" autocomplete="off" />
              <span>Exclude games released before</span>
            </label>

            <select id="releaseMonth" aria-label="Release month"></select>
            <select id="releaseYear" aria-label="Release year"></select>
          </div>
          <fieldset>
            <legend>Price & Revenue</legend>

            <div class="range-row">
              <label class="range-label">Price (USD)</label>
              <input id="priceMin" class="range-input" type="number" step="0.01" min="0" placeholder="min" />
              <span class="range-sep">–</span>
              <input id="priceMax" class="range-input" type="number" step="0.01" min="0" placeholder="max" />
              <small class="meta">Leave blank to ignore one side. If any bound is set, games with unknown price are
                excluded.</small>
            </div>

            <div class="range-row">
              <label class="range-label">Estimated Revenue</label>
              <input id="revMin" class="range-input" type="number" step="1" min="0" placeholder="min" />
              <span class="range-sep">–</span>
              <input id="revMax" class="range-input" type="number" step="1" min="0" placeholder="max" />
              <small class="meta">Revenue = reviews × price × 20. If any bound is set, games missing price/reviews are
                excluded.</small>
            </div>
          </fieldset>

        </fieldset>

        <fieldset>
          <legend>View</legend>
          <div class="toggle-row">
            <button type="button" class="toggle active" id="tThumbs" aria-pressed="true">Show thumbnails</button>
          </div>
          <div class="meta">Hide thumbnails to make entries more compact.</div>
        </fieldset>
      </div>
    </section>

    <section id="results" class="results"></section>

    <div id="pager" class="pager" style="display:none;">
      <button id="prevBtn" class="btn btn-ghost" disabled>Prev</button>
      <span id="pageInfo" class="meta">Page 1 of 1</span>
      <button id="nextBtn" class="btn">Next</button>
    </div>
  </main>

  <footer class="site-footer">
    <small>Static frontend for games.jsonl (Steam tags viewer)</small>
  </footer>

  <script>
    // ---------- Config ----------
    const JSON_LINES_PATH = 'games.jsonl';
    const PAGE_SIZE = 10;

    // ---------- State ----------
    let games = [];
    let queryTags = new Set();
    let bannedTags = new Set();
    let useTags = true, useGenres = false, useCategories = false, showThumbs = true;


    let currentPage = 1;
    let lastResults = [];
    let totalPages = 1;

    // always exclude the seed once set
    let seedExclude = null;

    const idx = { tags: new Map(), genres: new Map(), categories: new Map() };
    const byAppId = new Map();
    const byName = new Map();

    // ---------- Release-date filter ----------
    let releaseFilter = { on: false, y: null, m: null, cutoff: null };
    const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const firstOfMonthUTC = (y, m) => Date.UTC(y, m, 1);
    const fmtMonYear = ts => { const d = new Date(ts); return `${MONTHS[d.getUTCMonth()]} ${d.getUTCFullYear()}`; };
    function parseReleaseTs(raw) {
      if (!raw) return null;
      if (typeof raw === "number") return raw < 1e12 ? raw * 1000 : raw;
      if (typeof raw === "string") {
        const t = Date.parse(raw);
        if (!Number.isNaN(t)) return t;
        const m = raw.match(/^(\d{4})(?:-(\d{2}))?/);
        if (m) { const y = +m[1], mo = m[2] ? (+m[2] - 1) : 0; return Date.UTC(y, mo, 1); }
      }
      return null;
    }

    // ---------- DOM ----------
    const seedInput = document.getElementById('seedInput');
    const seedBtn = document.getElementById('seedBtn');
    const seedStatus = document.getElementById('seedStatus');

    const tagInput = document.getElementById('tagInput');
    const addBtn = document.getElementById('addBtn');
    const clearBtn = document.getElementById('clearBtn');
    const chipsEl = document.getElementById('activeTags');

    const banInput = document.getElementById('banInput');
    const banAddBtn = document.getElementById('banAddBtn');
    const banClearBtn = document.getElementById('banClearBtn');
    const bannedEl = document.getElementById('bannedTags');

    const resultsEl = document.getElementById('results');
    const scoreModeEls = document.querySelectorAll('input[name="scoreMode"]');
    const requireAllEl = document.getElementById('requireAll');
    const tTagsBtn = document.getElementById('tTags');
    const tGenresBtn = document.getElementById('tGenres');
    const tCategoriesBtn = document.getElementById('tCategories');
    const tThumbsBtn = document.getElementById('tThumbs');

    const priceMinEl = document.getElementById('priceMin');
    const priceMaxEl = document.getElementById('priceMax');
    const revMinEl = document.getElementById('revMin');
    const revMaxEl = document.getElementById('revMax');


    const releaseFilterOn = document.getElementById('releaseFilterOn');
    const releaseMonthSel = document.getElementById('releaseMonth');
    const releaseYearSel = document.getElementById('releaseYear');
    const ignoreUnreleasedEl = document.getElementById('ignoreUnreleased');

    const pagerEl = document.getElementById('pager');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const pageInfoEl = document.getElementById('pageInfo');

    // Force sane defaults on initial load (browsers may restore form/button state)
    useTags = true;
    tTagsBtn.classList.add('active');
    tTagsBtn.setAttribute('aria-pressed', 'true');


    // Do NOT hide unreleased by default
    if (ignoreUnreleasedEl) ignoreUnreleasedEl.checked = false;

    // Date filter OFF by default (critical for unreleased UX)
    if (releaseFilterOn) {
      releaseFilterOn.checked = false;  // checkbox state
      releaseFilter.on = false;         // internal state
    }



    // ---------- Utils ----------
    const normTag = t => t.trim().toLowerCase();
    const normName = s => (s || '').trim().toLowerCase();

    // price helpers (null price ≠ free)
    const isFreeGame = g => (g.is_free === true) || (g.price === 0);
    const formatPrice = p => (p == null) ? '—' : (p === 0 ? 'Free' : `$${Number(p).toFixed(2)}`);
    const estimateSalesUSD = g => {
      const r = g.reviews ?? 0;
      const p = isFreeGame(g) ? 0 : (g.price ?? 0);
      return (r > 0 && p > 0) ? r * p * 20 : 0;
    };
    const formatUSD = n => n ? n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }) : '—';

    function decileLabel(pct) {
      if (pct === 100) return 'exact match';
      const d = Math.floor(pct / 10) * 10;
      return ({
        90: 'almost exact', 80: 'highly similar', 70: 'very similar', 60: 'pretty similar',
        50: 'moderately similar', 40: 'somewhat similar', 30: 'loose match', 20: 'very weak match', 10: 'barely related'
      }[d]) || 'no real match';
    }
    const similarityColor = pct => `hsl(${Math.round((pct / 100) * 120)} 80% 55%)`;

    const readNum = el => {
      if (!el) return null;
      const v = (el.value ?? '').trim();
      if (v === '') return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };


    // ---------- Indexing ----------
    function addPosting(map, tag, gi) { if (!map.has(tag)) map.set(tag, []); map.get(tag).push(gi); }
    function buildIndices() {
      for (let gi = 0; gi < games.length; gi++) {
        const g = games[gi];
        (g.tags || []).forEach(t => addPosting(idx.tags, t, gi));
        (g.genres || []).forEach(t => addPosting(idx.genres, t, gi));
        (g.categories || []).forEach(t => addPosting(idx.categories, t, gi));
      }
      for (const map of [idx.tags, idx.genres, idx.categories]) {
        for (const [k, arr] of map.entries()) arr.sort((a, b) => a - b);
      }
    }
    function buildLookups() {
      for (let gi = 0; gi < games.length; gi++) {
        const g = games[gi];
        byAppId.set(String(g.app_id), gi);
        const nm = normName(g.name);
        if (!byName.has(nm)) byName.set(nm, []);
        byName.get(nm).push(gi);
      }
    }
    function postingsFor(tag, pools) {
      let out = [];
      for (const p of pools) {
        const arr = idx[p].get(tag) || [];
        if (out.length === 0) { out = out.concat(arr); continue; }
        let i = 0, j = 0, res = [], a = out, b = arr, last = null;
        while (i < a.length || j < b.length) {
          const va = i < a.length ? a[i] : Infinity;
          const vb = j < b.length ? b[j] : Infinity;
          let v;
          if (va < vb) { v = va; i++; }
          else if (vb < va) { v = vb; j++; }
          else { v = va; i++; j++; }
          if (v !== last) { res.push(v); last = v; }
        }
        out = res;
      }
      return out;
    }
    function intersectSorted(a, b) {
      const res = []; let i = 0, j = 0;
      while (i < a.length && j < b.length) {
        if (a[i] === b[j]) { res.push(a[i]); i++; j++; }
        else if (a[i] < b[j]) i++; else j++;
      }
      return res;
    }

    // ---------- Scoring ----------
    function buildTagSetFromPools(g, pools) {
      const s = new Set();
      if (pools.includes('tags')) (g.tags || []).forEach(t => s.add(t));
      if (pools.includes('genres')) (g.genres || []).forEach(t => s.add(t));
      if (pools.includes('categories')) (g.categories || []).forEach(t => s.add(t));
      return s;
    }
    function hasAnyBanned(g, pools) {
      if (bannedTags.size === 0) return false;
      const s = buildTagSetFromPools(g, pools);
      for (const bt of bannedTags) if (s.has(bt)) return true;
      return false;
    }
    function similarityScore(g, qSet, mode, pools, requireAll) {
      const gSet = buildTagSetFromPools(g, pools);
      let inter = 0; for (const t of qSet) if (gSet.has(t)) inter++;
      if (requireAll && inter < qSet.size) return { score: 0, inter };
      if (!inter) return { score: 0, inter };
      const score = (mode === 'containment')
        ? inter / Math.max(1, qSet.size)
        : inter / Math.max(1, new Set([...qSet, ...gSet]).size);
      return { score, inter };
    }

    // ---------- UI ----------
    function renderChips() {
      // Query chips
      chipsEl.innerHTML = '';
      if (queryTags.size === 0) {
        chipsEl.innerHTML = '<div class="hint">No active tags. Add some to see results.</div>';
      } else {
        for (const t of queryTags) {
          const chip = document.createElement('span'); chip.className = 'chip chip-query'; chip.textContent = t;
          const x = document.createElement('button'); x.className = 'chip-x'; x.type = 'button';
          x.setAttribute('aria-label', `Remove ${t}`); x.textContent = '×';
          x.onclick = (e) => { e.stopPropagation(); queryTags.delete(t); currentPage = 1; renderChips(); renderQuery(); };
          chip.appendChild(x); chipsEl.appendChild(chip);
        }
      }

      // Banned chips
      bannedEl.innerHTML = '';
      for (const t of bannedTags) {
        const chip = document.createElement('span'); chip.className = 'chip'; chip.textContent = t;
        const x = document.createElement('button'); x.className = 'chip-x'; x.type = 'button';
        x.setAttribute('aria-label', `Remove ${t}`); x.textContent = '×';
        x.onclick = (e) => { e.stopPropagation(); bannedTags.delete(t); currentPage = 1; renderChips(); renderQuery(); };
        chip.appendChild(x); bannedEl.appendChild(chip);
      }
    }

    function highlightTag(tag, q) {
      const s = document.createElement('span');
      s.className = q.has(tag) ? 'tag matched' : 'tag';
      s.textContent = tag;
      return s;
    }

    function renderPage() {
      resultsEl.innerHTML = '';
      const start = (currentPage - 1) * PAGE_SIZE;
      const slice = lastResults.slice(start, start + PAGE_SIZE);
      const q = new Set(queryTags);

      for (const item of slice) {
        const g = games[item.gIdx];
        const pct = Math.round(item.score * 100);
        const color = similarityColor(pct);
        const label = decileLabel(pct);

        const card = document.createElement('article');
        card.className = 'card';
        if (!showThumbs) card.classList.add('minimal');

        // Header
        const header = document.createElement('div'); header.className = 'card-header';
        if (showThumbs && g.header) {
          const img = document.createElement('img'); img.className = 'thumb thumb-inline';
          img.loading = 'lazy'; img.decoding = 'async'; img.alt = `${g.name} header image`; img.src = g.header;
          header.appendChild(img);
        }
        const title = document.createElement('h3'); title.className = 'title';
        const a = document.createElement('a'); a.href = `https://store.steampowered.com/app/${g.app_id}`; a.target = '_blank'; a.rel = 'noopener noreferrer'; a.textContent = g.name;
        title.appendChild(a); header.appendChild(title);

        const pill = document.createElement('span'); pill.className = 'sim-pill';
        pill.title = `Matched ${item.interCount} of ${q.size} query tag(s) • ${label}`;
        pill.textContent = `${pct}%`; pill.style.borderColor = color; pill.style.color = color;
        header.appendChild(pill);
        card.appendChild(header);

        // Meta row
        const devs = (g.developers && g.developers.length) ? g.developers.join(', ') : '—';
        const pubs = (g.publishers && g.publishers.length) ? g.publishers.join(', ') : '—';
        const estimate = estimateSalesUSD(g);

        const meta = document.createElement('div'); meta.className = 'meta-row';
        meta.innerHTML = `
          <span class="meta">Developer: ${devs}</span>
          <span class="meta">Publisher: ${pubs}</span>
          <span class="meta">Released: ${g.comingSoon ? 'Coming soon' : (g.releaseFmt ?? '—')}</span>
          <span class="meta">Price: ${formatPrice(g.price)}</span>
          <span class="meta">Reviews: ${(g.reviews || 0).toLocaleString()}</span>
          <span class="meta" title="Estimated = reviews × price × 20">Estimated Sales: ${formatUSD(estimate)}</span>
        `;
        card.appendChild(meta);

        // Similarity bar
        const barWrap = document.createElement('div'); barWrap.className = 'bar-wrap';
        const bar = document.createElement('div'); bar.className = 'bar'; bar.style.width = pct + '%'; bar.style.background = color;
        barWrap.appendChild(bar); card.appendChild(barWrap);

        // Tags
        const tagsDiv = document.createElement('div'); tagsDiv.className = 'tags';
        const pools = []; if (useTags) pools.push('tags'); if (useGenres) pools.push('genres'); if (useCategories) pools.push('categories');
        const show = []; if (pools.includes('tags')) show.push(...(g.tags || []));
        if (pools.includes('genres')) show.push(...(g.genres || []));
        if (pools.includes('categories')) show.push(...(g.categories || []));
        show.forEach(t => tagsDiv.appendChild(highlightTag(t, q)));
        card.appendChild(tagsDiv);

        resultsEl.appendChild(card);
      }

      pageInfoEl.textContent = `Page ${currentPage} of ${totalPages}`;
      prevBtn.disabled = currentPage <= 1;
      nextBtn.disabled = currentPage >= totalPages;
      pagerEl.style.display = totalPages > 1 ? '' : (queryTags.size ? '' : 'none');
    }

    function renderQuery() {
      // Hard-sync with actual checkboxes on every render
      const hideUnreleased = !!(ignoreUnreleasedEl && ignoreUnreleasedEl.checked);
      const dateOn = !!(releaseFilterOn && releaseFilterOn.checked);

      // keep the object in sync too (for other helpers that read it)
      releaseFilter.on = dateOn;

      const q = new Set(queryTags);
      if (q.size === 0) { resultsEl.innerHTML = ''; pagerEl.style.display = 'none'; return; }



      const pools = []; if (useTags) pools.push('tags'); if (useGenres) pools.push('genres'); if (useCategories) pools.push('categories');
      if (pools.length === 0) { resultsEl.innerHTML = '<div class="card">Enable at least one pool (Tags / Genres / Categories).</div>'; pagerEl.style.display = 'none'; return; }

      const tags = [...q];
      const lists = tags.map(t => postingsFor(t, pools));
      if (lists.every(l => l.length === 0)) { resultsEl.innerHTML = '<div class="card">No matches.</div>'; pagerEl.style.display = 'none'; return; }

      const requireAll = !!requireAllEl.checked;
      lists.sort((a, b) => a.length - b.length);
      let candidates = lists[0].slice();
      for (let i = 1; i < lists.length; i++) {
        candidates = requireAll ? intersectSorted(candidates, lists[i]) : (function union(a, b) {
          const out = []; let i = 0, j = 0, last = null;
          while (i < a.length || j < b.length) {
            const va = i < a.length ? a[i] : Infinity;
            const vb = j < b.length ? b[j] : Infinity;
            let v;
            if (va < vb) { v = va; i++; }
            else if (vb < va) { v = vb; j++; }
            else { v = va; i++; j++; }
            if (v !== last) { out.push(v); last = v; }
          }
          return out;
        })(candidates, lists[i]);
        if (requireAll && candidates.length === 0) break;
      }

      const mode = [...scoreModeEls].find(r => r.checked)?.value || 'containment';
      const results = [];
      for (const gi of candidates) {
        const g = games[gi];

        // Always exclude the seeded game if set
        if (seedExclude && (String(g.app_id) === seedExclude.app_id || normName(g.name) === seedExclude.name)) continue;

        // 1) Hide unreleased only when explicitly requested
        if (hideUnreleased && g.comingSoon) continue;

        // 2) Date filter: applies ONLY to released titles when ON
        if (dateOn && !g.comingSoon) {
          // If we don't know the release date, treat as "too old" → exclude
          if (!(typeof g.releaseTs === 'number')) continue;
          if (g.releaseTs < releaseFilter.cutoff) continue;
        }


        // 3) Banned tags
        if (hasAnyBanned(g, pools)) continue;

        // --- Price range filter ---
        const pMin = readNum(priceMinEl), pMax = readNum(priceMaxEl);
        if (pMin !== null || pMax !== null) {
          const price = g.price; // null means unknown
          if (price == null) continue; // exclude unknown when range is active
          if (pMin !== null && price < pMin) continue;
          if (pMax !== null && price > pMax) continue;
        }

        // --- Revenue range filter ---
        const rMin = readNum(revMinEl), rMax = readNum(revMaxEl);
        if (rMin !== null || rMax !== null) {
          const rev = estimateSalesUSD(g); // uses price & reviews
          if (!Number.isFinite(rev) || rev <= 0) {
            // If either price or reviews missing, we can’t estimate → exclude when range active
            continue;
          }
          if (rMin !== null && rev < rMin) continue;
          if (rMax !== null && rev > rMax) continue;
        }



        const { score, inter } = similarityScore(g, q, mode, pools, requireAll);
        if (score <= 0) continue;
        results.push({ gIdx: gi, score, interCount: inter });
      }

      // Sort: released first, higher score, more reviews, newer, name
      results.sort((a, b) => {
        const ga = games[a.gIdx], gb = games[b.gIdx];

        // 1) Higher similarity first
        if (b.score !== a.score) return b.score - a.score;

        // 2) More reviews first
        const ar = ga.reviews || 0, br = gb.reviews || 0;
        if (br !== ar) return br - ar;

        // 3) Newer release first (unknown/null = 0)
        const at = ga.releaseTs || 0, bt = gb.releaseTs || 0;
        if (bt !== at) return bt - at;

        // 4) As a FINAL tie-breaker only, prefer released over coming soon
        const aSoon = !!ga.comingSoon, bSoon = !!gb.comingSoon;
        if (aSoon !== bSoon) return aSoon ? 1 : -1;

        // 5) Stable tie-breaker by name
        return normName(ga.name).localeCompare(normName(gb.name));
      });


      // De-dupe by (name + release status)
      const seen = new Set();
      lastResults = results.filter(r => {
        const g = games[r.gIdx];
        const key = `${normName(g.name)}::${g.comingSoon ? 'soon' : 'released'}`;
        if (seen.has(key)) return false;
        seen.add(key); return true;
      });

      totalPages = Math.max(1, Math.ceil(lastResults.length / PAGE_SIZE));
      currentPage = Math.min(currentPage, totalPages);
      renderPage();
    }



    // ---------- Seed ----------
    function parseSeedToAppId(str) {
      const s = (str || '').trim(); if (!s) return null;
      if (/^\d+$/.test(s)) return s;
      const m = s.match(/store\.steampowered\.com\/app\/(\d+)/i); if (m) return m[1];
      return null;
    }
    function findGameBySeed(seedRaw) {
      const appId = parseSeedToAppId(seedRaw);
      if (appId) { if (byAppId.has(String(appId))) return games[byAppId.get(String(appId))]; return null; }
      const nm = normName(seedRaw); if (!nm) return null;
      const arr = byName.get(nm); if (!arr || arr.length === 0) return null;
      const bestGi = arr.slice().sort((a, b) => (games[b].reviews || 0) - (games[a].reviews || 0))[0];
      return games[bestGi];
    }
    function injectTagsFromGame(g) {
      const pools = []; if (useTags) pools.push('tags'); if (useGenres) pools.push('genres'); if (useCategories) pools.push('categories');
      const incoming = []; if (pools.includes('tags')) incoming.push(...(g.tags || []));
      if (pools.includes('genres')) incoming.push(...(g.genres || []));
      if (pools.includes('categories')) incoming.push(...(g.categories || []));
      let added = 0;
      for (const t of incoming) {
        const nt = normTag(t);
        const before = queryTags.size; queryTags.add(nt);
        if (queryTags.size > before) added++;
      }
      return { added, total: incoming.length };
    }
    function handleSeed() {
      seedStatus.textContent = '';
      const raw = seedInput.value.trim();
      if (!raw) { seedStatus.textContent = 'Enter a Steam URL, AppID, or exact game name.'; return; }
      const g = findGameBySeed(raw);
      if (!g) { seedStatus.textContent = 'That game isn’t in this list.'; return; }
      const { added, total } = injectTagsFromGame(g);
      seedExclude = { app_id: String(g.app_id), name: normName(g.name) }; // always exclude itself
      seedStatus.textContent = `Loaded ${added}/${total} tag(s) from “${g.name}”. (Excluded itself from results)`;
      currentPage = 1; renderChips(); renderQuery();
    }

    // ---------- Events ----------
    function parseFreeformTags(str) {
      const parts = str.split(/,/).map(s => s.trim()).filter(Boolean);
      return parts.map(p => normTag(p.replace(/^["'](.*)["']$/s, '$1')));
    }
    seedBtn.addEventListener('click', handleSeed);
    seedInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); handleSeed(); } });

    tagInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        parseFreeformTags(tagInput.value).forEach(t => queryTags.add(t));
        tagInput.value = ''; currentPage = 1; renderChips(); renderQuery();
      }
    });
    addBtn.onclick = () => { parseFreeformTags(tagInput.value).forEach(t => queryTags.add(t)); tagInput.value = ''; currentPage = 1; renderChips(); renderQuery(); };
    clearBtn.onclick = () => { queryTags.clear(); currentPage = 1; renderChips(); renderQuery(); };

    banInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        parseFreeformTags(banInput.value).forEach(t => bannedTags.add(t));
        banInput.value = ''; currentPage = 1; renderChips(); renderQuery();
      }
    });
    banAddBtn.onclick = () => { parseFreeformTags(banInput.value).forEach(t => bannedTags.add(t)); banInput.value = ''; currentPage = 1; renderChips(); renderQuery(); };
    banClearBtn.onclick = () => { bannedTags.clear(); currentPage = 1; renderChips(); renderQuery(); };

    [...scoreModeEls, requireAllEl].forEach(el => el.addEventListener('change', () => { currentPage = 1; renderQuery(); }));

    function toggleButton(btn, setter) {
      const active = btn.classList.toggle('active');
      btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      setter(active); currentPage = 1; renderQuery();
    }
    tTagsBtn.addEventListener('click', () => toggleButton(tTagsBtn, v => useTags = v));
    tGenresBtn.addEventListener('click', () => toggleButton(tGenresBtn, v => useGenres = v));
    tCategoriesBtn.addEventListener('click', () => toggleButton(tCategoriesBtn, v => useCategories = v));
    tThumbsBtn.addEventListener('click', () => toggleButton(tThumbsBtn, v => showThumbs = v));

    prevBtn.addEventListener('click', () => { if (currentPage > 1) { currentPage--; renderPage(); } });
    nextBtn.addEventListener('click', () => { if (currentPage < totalPages) { currentPage++; renderPage(); } });

    [priceMinEl, priceMaxEl, revMinEl, revMaxEl].forEach(el => {
      if (!el) return;
      el.addEventListener('input', () => { currentPage = 1; renderQuery(); });
      el.addEventListener('change', () => { currentPage = 1; renderQuery(); });
    });


    // ---------- Load ----------
    (async () => {
      try {
        const res = await fetch(JSON_LINES_PATH, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Could not load ${JSON_LINES_PATH}`);
        const text = await res.text();

        games = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean).map(l => {
          const j = JSON.parse(l);
          const cls = j.classification || {};
          const id = j.identity || {};
          const media = j.media || {};

          const relRaw =
            j.release?.date_iso ??
            j.release?.date_raw ??
            id.release_date ??
            j.release_date ??
            j.meta?.release_date;

          const relTs = parseReleaseTs(relRaw);
          const arr = v => Array.isArray(v) ? v : (v ? [v] : []);

          return {
            app_id: j.app_id,
            name: id.name || `App ${j.app_id}`,

            // classification pools (normalized)
            tags: arr(cls.tags).map(normTag),
            genres: arr(cls.genres).map(normTag),
            categories: arr(cls.categories).map(normTag),

            // credits (keep original casing)
            developers: Array.isArray(id.developers) ? id.developers : (id.developers ? [id.developers] : []),
            publishers: Array.isArray(id.publishers) ? id.publishers : (id.publishers ? [id.publishers] : []),

            price: j.pricing ? j.pricing.price_usd : null,
            is_free: !!(j.pricing && j.pricing.is_free),

            // reviews (fallbacks)
            reviews: (j.reviews?.review_count) ?? (j.reviews?.total_reviews) ?? 0,

            header: media.header_image || null,

            releaseTs: relTs,
            releaseFmt: relTs ? fmtMonYear(relTs) : null,
            comingSoon: !!(j.release && j.release.coming_soon)
          };
        });

        buildIndices();
        buildLookups();

        // Populate release selects
        const yearsInData = games.map(g => g.releaseTs).filter(Boolean).map(ts => new Date(ts).getUTCFullYear());
        const minYear = yearsInData.length ? Math.min(...yearsInData) : 1997;
        const maxYear = yearsInData.length ? Math.max(...yearsInData) : (new Date()).getUTCFullYear();

        releaseMonthSel.innerHTML = MONTHS.map((m, i) => `<option value="${i}">${m}</option>`).join('');
        let yOpts = ''; for (let y = maxYear; y >= minYear; y--) yOpts += `<option value="${y}">${y}</option>`;
        releaseYearSel.innerHTML = yOpts;

        releaseMonthSel.value = String((new Date()).getUTCMonth());
        releaseYearSel.value = String((new Date()).getUTCFullYear());

        function updateReleaseCutoff() {
          const y = +releaseYearSel.value, m = +releaseMonthSel.value;
          releaseFilter.y = y; releaseFilter.m = m; releaseFilter.cutoff = firstOfMonthUTC(y, m);
          currentPage = 1; renderQuery();
        }

        releaseFilterOn.addEventListener('change', () => {
          // Trust the checkbox; render will re-sync too
          if (releaseFilterOn.checked) {
            updateReleaseCutoff();
          } else {
            releaseFilter.on = false; // explicit
            currentPage = 1;
            renderQuery();
          }
        });

        // Only recompute cutoff if the feature is ON
        releaseMonthSel.addEventListener('change', () => {
          if (releaseFilterOn && releaseFilterOn.checked) updateReleaseCutoff();
        });
        releaseYearSel.addEventListener('change', () => {
          if (releaseFilterOn && releaseFilterOn.checked) updateReleaseCutoff();
        });


        if (ignoreUnreleasedEl) {
          ignoreUnreleasedEl.addEventListener('change', () => { currentPage = 1; renderQuery(); });
        }

      } catch (err) {
        resultsEl.innerHTML = `<div class="card">${err.message}</div>`;
        return;
      }
      renderChips(); // wait for user query
    })();
  </script>
</body>

</html>