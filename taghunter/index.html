---
layout: default
title: "Tag Hunter"
permalink: /taghunter/
body_classes: page-tools
---

<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Steam Tag Hunter</title>
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="wrap">
      <h1>Steam Tag Hunter</h1>
      <p class="sub">Find games based on tag similarity…</p>
    </div>
  </header>

  <!-- Loader -->
  <div id="loader" class="loader">
    <div class="loader-card">
      <div class="loader-head">
        <strong>Loading games…</strong>
        <span id="loaderPct" class="muted">0%</span>
      </div>
      <div class="bar">
        <div id="loaderBar" class="bar-fill"></div>
      </div>
      <div id="loaderMeta" class="muted small">0 parsed</div>
    </div>
  </div>

  <main class="container">
    <section class="controls controls-emphasis">
      <!-- Seed -->
      <div class="input-row seed-wrap">
        <input id="seedInput" class="input-main" type="text"
          placeholder="Paste a Steam URL, AppID, or game name (2+ chars for fuzzy)…" autocomplete="off" />
        <button id="seedBtn" class="btn">Load tags</button>
        <div id="seedSuggest" class="seed-suggest" role="listbox" aria-label="Game suggestions"></div>
      </div>
      <small id="seedStatus" class="meta" aria-live="polite"></small>

      <!-- Query tags -->
      <div class="input-row">
        <input id="tagInput" class="input-main" type="text" placeholder='e.g., FPS, Multiplayer, Cold War' />
        <button id="addBtn" class="btn btn-accent">Add tag(s)</button>
        <button id="clearBtn" class="btn btn-ghost">Clear tags</button>
      </div>
      <div id="activeTags" class="chips query-chips"></div>

      <!-- Banned tags -->
      <div class="input-row" style="margin-top:.4rem;">
        <input id="banInput" class="input-main" type="text" placeholder="Banned tags (comma-separated)" />
        <button id="banAddBtn" class="btn">Add banned</button>
        <button id="banClearBtn" class="btn btn-ghost">Clear banned</button>
      </div>
      <div class="banned-label">Games that contain any banned tag will be excluded.</div>
      <div id="bannedTags" class="chips banned-chips" style="margin-top:.25rem;"></div>

      <div class="options">
        <!-- Scoring -->
        <fieldset>
          <legend>Scoring</legend>
          <label><input type="radio" name="scoreMode" value="containment" checked /> Containment</label>
          <label><input type="radio" name="scoreMode" value="jaccard" /> Jaccard</label>

          <div class="help-inline">
            <button type="button" class="btn btn-ghost btn-help" id="openScoreHelp">
              What’s the difference?
            </button>
          </div>

<dialog id="scoreDialog" class="modal score-modal">
  <form method="dialog" class="modal__panel" aria-labelledby="scoreDlgTitle">
    <header class="modal__header">
      <div>
        <h3 id="scoreDlgTitle">Scoring: Containment vs Jaccard</h3>
        <p class="modal__subtitle">
          Two ways to measure overlap between your query tags and a game’s tags.
        </p>
      </div>
      <button class="modal__close" aria-label="Close scoring help" type="button">×</button>
    </header>

    <section class="modal__content">
      <div class="modal__grid">
        <article class="modal__card">
          <div class="modal__cardHead">
            <span class="badge badge-contain">Default</span>
            <h4>Containment</h4>
          </div>
          <p class="eq">
            <code>score = overlap ÷ your&nbsp;query&nbsp;size</code>
          </p>
          <ul class="use-for">
            <li>“Did it match the tags I explicitly asked for?”</li>
            <li>Extra tags on the game <strong>don’t lower</strong> the score.</li>
            <li>Great when you have a focused shopping list of tags.</li>
          </ul>
        </article>

        <article class="modal__card">
          <div class="modal__cardHead">
            <span class="badge">Alt</span>
            <h4>Jaccard</h4>
          </div>
          <p class="eq">
            <code>score = overlap ÷ union</code>
          </p>
          <ul class="use-for">
            <li>Measures overall “vibe similarity.”</li>
            <li>Unrelated extra tags <strong>do lower</strong> the score.</li>
            <li>Great when you want games that “feel” like your query.</li>
          </ul>
        </article>
      </div>

      <!-- Hypothetical tag search example -->
      <div class="score-example">
        <h4 class="score-example__title">Example search</h4>
        <p class="score-example__subtitle">
          Query tags:
        </p>
        <div class="score-example__chips">
          <span class="chip chip--tiny chip--query">roguelike</span>
          <span class="chip chip--tiny chip--query">deckbuilder</span>
          <span class="chip chip--tiny chip--query">turn-based</span>
        </div>

        <div class="score-example__rows">
          <div class="score-example__game">
            <div class="score-example__head">
              <span class="score-example__name">Game A</span>
              <span class="score-example__pill">Containment: 100% · Jaccard: 60%</span>
            </div>
            <div class="score-example__chips">
              <span class="chip chip--tiny chip--match">roguelike</span>
              <span class="chip chip--tiny chip--match">deckbuilder</span>
              <span class="chip chip--tiny chip--match">turn-based</span>
              <span class="chip chip--tiny chip--extra">indie</span>
              <span class="chip chip--tiny chip--extra">pixel graphics</span>
            </div>
            <p class="score-example__note">
              Matches <strong>all 3</strong> query tags. Containment is 3/3 = 1.0 (100%).
              Jaccard is 3 / 5 = 0.6 (extra tags dilute the “vibe” a bit).
            </p>
          </div>

          <div class="score-example__game">
            <div class="score-example__head">
              <span class="score-example__name">Game B</span>
              <span class="score-example__pill">Containment: 67% · Jaccard: 67%</span>
            </div>
            <div class="score-example__chips">
              <span class="chip chip--tiny chip--match">roguelike</span>
              <span class="chip chip--tiny chip--match">deckbuilder</span>
              <span class="chip chip--tiny chip--miss">real-time</span>
            </div>
            <p class="score-example__note">
              Only <strong>2 of your 3</strong> query tags match.  
              Containment is 2/3 ≈ 0.67, and there are no unrelated extras, so
              Jaccard is also 2 / 3 ≈ 0.67.
            </p>
          </div>
        </div>
      </div>
    </section>

    <footer class="modal__footer">
      <button class="btn btn-accent" type="submit">Got it</button>
    </footer>
  </form>
</dialog>

        </fieldset>

        <!-- Match & Release (tags-only now) -->
        <fieldset>
          <legend>Match & Release</legend>

          <label class="require-all"><input type="checkbox" id="requireAll" /> Hide games missing any query tag</label>

          <div class="toggle-row" style="margin-top:.25rem">
            <label class="require-all"><input type="checkbox" id="ignoreUnreleased" autocomplete="off" /> Hide
              unreleased</label>
          </div>

          <!-- Release date RANGE -->
          <div class="date-filter nowrap">
            <label class="date-filter-label">
              <input type="checkbox" id="releaseRangeOn" autocomplete="off" />
              <span>Filter by release date range</span>
            </label>

            <div class="date-group">
              <span class="meta">From</span>
              <select id="relStartMonth" aria-label="Start month"></select>
              <select id="relStartYear" aria-label="Start year"></select>
            </div>

            <div class="date-group">
              <span class="meta">to</span>
              <select id="relEndMonth" aria-label="End month"></select>
              <select id="relEndYear" aria-label="End year"></select>
            </div>
          </div>
        </fieldset>

        <!-- Filters -->
        <fieldset>
          <legend>Filters</legend>
          <small class="meta">Leave blank to ignore a side. If any bound is set, unknown prices are excluded.</small>

          <div class="range-row">
            <label class="range-label">Price (USD)</label>
            <div class="range-inputs">
              <input id="priceMin" class="range-input" type="number" step="0.01" min="0" placeholder="min" />
              <span class="range-sep">–</span>
              <input id="priceMax" class="range-input" type="number" step="0.01" min="0" placeholder="max" />
            </div>
          </div>

          <div class="range-row">
            <label class="range-label">Estimated Revenue</label>
            <div class="range-inputs">
              <input id="revMin" class="range-input" type="number" step="1" min="0" placeholder="min" />
              <span class="range-sep">–</span>
              <input id="revMax" class="range-input" type="number" step="1" min="0" placeholder="max" />
            </div>
          </div>
        </fieldset>
      </div>
    </section>

    <section id="results" class="results"></section>

    <div id="pager" class="pager" style="display:none;">
      <button id="prevBtn" class="btn btn-ghost" disabled>Prev</button>
      <span id="pageInfo" class="meta">Page 1 of 1</span>
      <button id="nextBtn" class="btn">Next</button>
    </div>
  </main>

  <script>
    // ---------- Config ----------
    const JSON_LINES_PATH = 'https://bluepinstudio.github.io/sg/games.compact.jsonl';
    const PAGE_SIZE = 12;
    const EXPECTED_TOTAL_GAMES_HINT = 163000;

    // ---------- State ----------
    let games = [];
    let queryTags = new Set();
    let bannedTags = new Set();
    let forcedTags = new Set();  // tags "pinned" by clicking chips
    let showThumbs = true; // view option hook (safe even if not present)

    let currentPage = 1;
    let lastResults = [];
    let totalPages = 1;

    let requiredCount = 0; // how many query tags actually exist in data
    let seedExclude = null;

    const idx = { tags: new Map() };
    const byAppId = new Map();
    const byName = new Map();

    // Fuzzy index
    let nameIndex = []; // [{gi, name, n, grams:Set<string>, reviews:number}, ...]
    let activeSuggestIndex = -1;

    // ---------- Release-date RANGE filter ----------
    let releaseFilter = { on: false, sy: null, sm: null, ey: null, em: null, start: null, end: null };
    const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const firstOfMonthUTC = (y, m) => Date.UTC(y, m, 1);
    const lastOfMonthUTC = (y, m) => Date.UTC(y, m + 1, 0, 23, 59, 59, 999);
    const fmtMonYear = ts => { const d = new Date(ts); return `${MONTHS[d.getUTCMonth()]} ${d.getUTCFullYear()}`; };
    function parseReleaseTs(raw) {
      if (!raw) return null;
      if (typeof raw === "number") return raw < 1e12 ? raw * 1000 : raw;
      if (typeof raw === "string") {
        const t = Date.parse(raw);
        if (!Number.isNaN(t)) return t;
        const m = raw.match(/^(\d{4})(?:-(\d{2}))?/);
        if (m) { const y = +m[1], mo = m[2] ? (+m[2] - 1) : 0; return Date.UTC(y, mo, 1); }
      }
      return null;
    }

    // ---------- DOM ----------
    const seedInput = document.getElementById('seedInput');
    const seedBtn = document.getElementById('seedBtn');
    const seedStatus = document.getElementById('seedStatus');
    const seedSuggest = document.getElementById('seedSuggest');

    const tagInput = document.getElementById('tagInput');
    const addBtn = document.getElementById('addBtn');
    const clearBtn = document.getElementById('clearBtn');
    const chipsEl = document.getElementById('activeTags');

    const banInput = document.getElementById('banInput');
    const banAddBtn = document.getElementById('banAddBtn');
    const banClearBtn = document.getElementById('banClearBtn');
    const bannedEl = document.getElementById('bannedTags');

    const resultsEl = document.getElementById('results');
    const scoreModeEls = document.querySelectorAll('input[name="scoreMode"]');
    const requireAllEl = document.getElementById('requireAll');

    const priceMinEl = document.getElementById('priceMin');
    const priceMaxEl = document.getElementById('priceMax');
    const revMinEl = document.getElementById('revMin');
    const revMaxEl = document.getElementById('revMax');

    const openScoreHelpBtn = document.getElementById('openScoreHelp');
    const scoreDialog = document.getElementById('scoreDialog');

    // Range controls
    const releaseRangeOn = document.getElementById('releaseRangeOn');
    const relStartMonth = document.getElementById('relStartMonth');
    const relStartYear = document.getElementById('relStartYear');
    const relEndMonth = document.getElementById('relEndMonth');
    const relEndYear = document.getElementById('relEndYear');

    const ignoreUnreleasedEl = document.getElementById('ignoreUnreleased');

    const pagerEl = document.getElementById('pager');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const pageInfoEl = document.getElementById('pageInfo');

    // Loader DOM
    const loader = document.getElementById('loader');
    const loaderBar = document.getElementById('loaderBar');
    const loaderPct = document.getElementById('loaderPct');
    const loaderMeta = document.getElementById('loaderMeta');

    // ---------- Utils ----------
    const normTag = t => t.trim().toLowerCase();
    const normName = s => (s || '').trim().toLowerCase();
    const idle = () => new Promise(r => setTimeout(r, 0));

    // ---------- Scoring help modal wiring ----------
    if (openScoreHelpBtn && scoreDialog) {
      // Open on button click
      openScoreHelpBtn.addEventListener('click', () => {
        try {
          scoreDialog.showModal();
        } catch (e) {
          // Fallback if <dialog> isn't supported as a modal
          scoreDialog.setAttribute('open', 'open');
        }
      });

      // Close when clicking the ✕ button
      const closeBtn = scoreDialog.querySelector('.modal__close');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.preventDefault();
          scoreDialog.close?.();
          scoreDialog.removeAttribute('open');
        });
      }

      // Ensure "Got it" / ESC / Enter closes cleanly
      scoreDialog.addEventListener('close', () => {
        scoreDialog.removeAttribute('open');
      });

      // Optional: close if user clicks the backdrop area (outside the panel)
      scoreDialog.addEventListener('click', (e) => {
        if (e.target === scoreDialog) {
          scoreDialog.close?.();
          scoreDialog.removeAttribute('open');
        }
      });
    }

    function gramify(s) {
      const cleaned = (s || '').toLowerCase().replace(/[^a-z0-9]/g, '');
      const grams = new Set();
      if (cleaned.length === 0) return grams;
      if (cleaned.length < 3) { grams.add(cleaned); return grams; }
      for (let i = 0; i + 2 < cleaned.length; i++) grams.add(cleaned.slice(i, i + 3));
      return grams;
    }

    function jaccard(a, b) {
      if (!a.size || !b.size) return 0;
      let inter = 0;
      const small = a.size < b.size ? a : b;
      const large = a.size < b.size ? b : a;
      for (const g of small) if (large.has(g)) inter++;
      const uni = a.size + b.size - inter;
      return inter / uni;
    }

    function fuzzyScore(query, item) {
      const qn = normName(query);
      const gramsQ = gramify(qn);
      const base = jaccard(gramsQ, item.grams);
      const substring = item.n.includes(qn);
      const prefix = item.n.startsWith(qn);
      let score = base;
      if (substring) score += 0.25;
      if (prefix) score += 0.15;
      if (base > 0.05 || substring || prefix) {
        score += Math.min(0.15, ((item.reviews || 0) / 500000) * 0.15);
      }
      return { score, base, substring, prefix };
    }

    const isFreeGame = g => (g.is_free === true) || (g.price === 0);
    const formatPrice = p => (p == null) ? '—' : (p === 0 ? 'Free' : `$${Number(p).toFixed(2)}`);
    const estimateSalesUSD = g => {
      const r = g.reviews ?? 0;
      const p = isFreeGame(g) ? 0 : (g.price ?? 0);
      return (r > 0 && p > 0) ? r * p * 20 : 0;
    };
    const formatUSD = n => n ? n.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }) : '—';

    function decileLabel(pct) {
      if (pct === 100) return 'exact match';
      const d = Math.floor(pct / 10) * 10;
      return ({
        90: 'almost exact', 80: 'highly similar', 70: 'very similar', 60: 'pretty similar',
        50: 'moderately similar', 40: 'somewhat similar', 30: 'loose match', 20: 'very weak match', 10: 'barely related'
      }[d]) || 'no real match';
    }
    const similarityColor = pct => `hsl(${Math.round((pct / 100) * 120)} 80% 55%)`;

    const readNum = el => {
      if (!el) return null;
      const v = (el.value ?? '').trim();
      if (v === '') return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    const { hideLoader, loadJSONLStream } = createJSONLLoader(EXPECTED_TOTAL_GAMES_HINT);

    function createJSONLLoader(expectedTotalHint) {
      const fmtInt = n => Number.isFinite(n) ? n.toLocaleString() : '?';

      function hideLoader() {
        if (!loader) return;
        loader.classList.add('hide');
        setTimeout(() => {
          try { loader.remove(); } catch { }
        }, 350);
      }

      function updateLoaderProgress({
        receivedBytes = 0,
        totalBytes = 0,
        parsedCount = 0,
        estTotalCount = null,
        streamDone = false
      }) {
        if (!loaderBar || !loaderPct || !loaderMeta) return;

        const denom = Number.isFinite(estTotalCount) && estTotalCount > 0
          ? estTotalCount
          : (expectedTotalHint || null);

        const pctGames = (denom && denom > 0)
          ? Math.max(0, Math.min(1, parsedCount / denom))
          : null;

        const pctBytes = (totalBytes > 0)
          ? Math.max(0, Math.min(1, receivedBytes / totalBytes))
          : null;

        let pct = null;
        if (pctGames != null && pctBytes != null) {
          pct = Math.min(pctGames, pctBytes);
        } else {
          pct = (pctGames ?? pctBytes ?? 0);
        }

        if (streamDone && pct < 0.98 && (denom || pctGames != null)) {
          pct = Math.min(pct, 0.98);
        }

        const pctDisplay = Math.round(pct * 100);
        loaderBar.style.width = pctDisplay + '%';
        loaderPct.textContent = pctDisplay + '%';

        if (denom) {
          loaderMeta.textContent = `${fmtInt(parsedCount)} of ${fmtInt(denom)} parsed`;
        } else if (totalBytes) {
          loaderMeta.textContent =
            `${fmtInt(parsedCount)} parsed -> ${fmtInt(receivedBytes)} / ${fmtInt(totalBytes)} bytes`;
        } else {
          loaderMeta.textContent = `${fmtInt(parsedCount)} parsed`;
        }
      }

      async function parseTextInChunks(text, totalBytes, onLine = () => true) {
        const lines = text.split(/\r?\n/);
        const estTotalCount = expectedTotalHint || lines.length;
        let parsedCount = 0;
        const total = totalBytes || text.length || lines.length;

        for (let i = 0; i < lines.length; i++) {
          const raw = lines[i].trim();
          if (!raw) continue;

          let accepted = false;
          try { accepted = onLine(raw) !== false; } catch { accepted = false; }
          if (accepted) parsedCount++;

          if (i % 2000 === 0) {
            updateLoaderProgress({
              receivedBytes: Math.min(total, i),
              totalBytes: total,
              parsedCount,
              estTotalCount,
              streamDone: false
            });
            await idle();
          }
        }

        updateLoaderProgress({
          receivedBytes: total,
          totalBytes: total,
          parsedCount,
          estTotalCount,
          streamDone: true
        });

        return parsedCount;
      }

      async function loadJSONLStream(url, onLine = () => true) {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Could not load ${url}`);

        const totalBytes = +res.headers.get('content-length') || 0;
        const reader = res.body && res.body.getReader ? res.body.getReader() : null;

        if (!reader) {
          const text = await res.text();
          return parseTextInChunks(text, totalBytes, onLine);
        }

        const decoder = new TextDecoder();
        let buffer = '';
        let parsedCount = 0;
        let receivedBytes = 0;

        let estTotalCount = expectedTotalHint || null;
        let bytesForSamples = 0;
        let linesInSamples = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          receivedBytes += value.byteLength;
          buffer += decoder.decode(value, { stream: true });

          const parts = buffer.split(/\r?\n/);
          buffer = parts.pop() ?? '';

          for (const line of parts) {
            const raw = line.trim();
            if (!raw) continue;

            bytesForSamples += raw.length + 1;
            linesInSamples += 1;

            let accepted = false;
            try { accepted = onLine(raw) !== false; } catch { accepted = false; }
            if (accepted) parsedCount++;

            if (parsedCount % 2000 === 0) {
              await idle();
            }
          }

          if (!estTotalCount && totalBytes > 0 && linesInSamples > 0) {
            const avgBytesPerLine = bytesForSamples / linesInSamples;
            if (avgBytesPerLine > 5) {
              estTotalCount = Math.max(
                parsedCount,
                Math.floor(totalBytes / avgBytesPerLine)
              );
            }
          }

          updateLoaderProgress({
            receivedBytes,
            totalBytes,
            parsedCount,
            estTotalCount,
            streamDone: false
          });
        }

        if (buffer.trim()) {
          let accepted = false;
          try { accepted = onLine(buffer.trim()) !== false; } catch { accepted = false; }
          if (accepted) parsedCount++;
        }

        updateLoaderProgress({
          receivedBytes: totalBytes || 1,
          totalBytes: totalBytes || 1,
          parsedCount,
          estTotalCount,
          streamDone: true
        });

        return parsedCount;
      }

      return { hideLoader, loadJSONLStream, updateLoaderProgress };
    }
    // ---------- Indexing ----------
    function addPosting(map, tag, gi) { if (!map.has(tag)) map.set(tag, []); map.get(tag).push(gi); }
    function buildIndices() {
      for (let gi = 0; gi < games.length; gi++) {
        const g = games[gi];
        (g.tags || []).forEach(t => addPosting(idx.tags, t, gi));
      }
      for (const [k, arr] of idx.tags.entries()) arr.sort((a, b) => a - b);
    }
    function buildLookups() {
      nameIndex = [];
      for (let gi = 0; gi < games.length; gi++) {
        const g = games[gi];
        byAppId.set(String(g.app_id), gi);
        const nm = normName(g.name);
        if (!byName.has(nm)) byName.set(nm, []);
        byName.get(nm).push(gi);
        nameIndex.push({
          gi,
          name: g.name,
          n: nm,
          grams: gramify(nm),
          reviews: g.reviews || 0
        });
      }
    }
    function postingsFor(tag) { return idx.tags.get(tag) || []; }
    function intersectSorted(a, b) {
      const res = []; let i = 0, j = 0;
      while (i < a.length && j < b.length) {
        if (a[i] === b[j]) { res.push(a[i]); i++; j++; }
        else if (a[i] < b[j]) i++; else j++;
      }
      return res;
    }

    // ---------- Scoring ----------
    function buildTagSet(g) {
      const s = new Set();
      (g.tags || []).forEach(t => s.add(t));
      return s;
    }
    function hasAnyBanned(g) {
      if (bannedTags.size === 0) return false;
      const s = buildTagSet(g);
      for (const bt of bannedTags) if (s.has(bt)) return true;
      return false;
    }
    function similarityScore(g, qSet, mode) {
      const gSet = buildTagSet(g);
      let inter = 0;
      for (const t of qSet) if (gSet.has(t)) inter++;
      const containsAll = inter === qSet.size;
      const exactOnly = containsAll && gSet.size === qSet.size;
      if (inter === 0) return { score: 0, inter, gSize: gSet.size, containsAll, exactOnly };
      const score = (mode === 'containment')
        ? inter / Math.max(1, qSet.size)
        : inter / Math.max(1, new Set([...qSet, ...gSet]).size);
      return { score, inter, gSize: gSet.size, containsAll, exactOnly };
    }

    // ---------- UI ----------
    function renderChips() {
      chipsEl.innerHTML = '';
      if (queryTags.size === 0) {
        chipsEl.innerHTML = '<div class="hint">No active tags. Add some to see results.</div>';
      } else {
        for (const t of queryTags) {
          const chip = document.createElement('span');
          chip.className = 'chip chip-query';
          if (forcedTags.has(t)) chip.classList.add('chip-forced'); // visually mark forced tags
          chip.textContent = t;
          chip.dataset.tag = t;

          const x = document.createElement('button');
          x.className = 'chip-x';
          x.type = 'button';
          x.setAttribute('aria-label', `Remove ${t}`);
          x.textContent = '×';

          // Click on the X: remove tag (and unforce it)
          x.onclick = (e) => {
            e.stopPropagation();
            queryTags.delete(t);
            forcedTags.delete(t);
            currentPage = 1;
            renderChips();
            renderQuery();
          };

          chip.appendChild(x);

          // Click on the chip body: toggle forced state
          chip.addEventListener('click', (e) => {
            // if user clicked the X, do nothing here
            if (e.target === x) return;

            if (forcedTags.has(t)) {
              forcedTags.delete(t);
            } else {
              forcedTags.add(t);
            }
            currentPage = 1;
            renderChips();
            renderQuery();
          });

          chipsEl.appendChild(chip);
        }
      }

      bannedEl.innerHTML = '';
      for (const t of bannedTags) {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.textContent = t;
        const x = document.createElement('button');
        x.className = 'chip-x';
        x.type = 'button';
        x.setAttribute('aria-label', `Remove ${t}`);
        x.textContent = '×';
        x.onclick = (e) => {
          e.stopPropagation();
          bannedTags.delete(t);
          currentPage = 1;
          renderChips();
          renderQuery();
        };
        chip.appendChild(x);
        bannedEl.appendChild(chip);
      }
    }


    function renderPage() {
      resultsEl.innerHTML = '';
      const start = (currentPage - 1) * PAGE_SIZE;
      const slice = lastResults.slice(start, start + PAGE_SIZE);
      const q = new Set(queryTags);

      for (const item of slice) {
        const g = games[item.gIdx];
        const pct = Math.round(item.score * 100);
        const color = similarityColor(pct);
        const label = decileLabel(pct);

        const card = document.createElement('article');
        card.className = 'card';

        // --- TOP BAR (moved to top of card) ---
        const barWrap = document.createElement('div');
        barWrap.className = 'bar-wrap bar-wrap-top';
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.width = pct + '%';
        bar.style.background = color;
        barWrap.appendChild(bar);
        card.appendChild(barWrap);
        // ---------------------------------------

        const header = document.createElement('div');
        header.className = 'card-header';
        if (showThumbs && g.header) {
          const img = document.createElement('img');
          img.className = 'thumb thumb-inline';
          img.loading = 'lazy';
          img.decoding = 'async';
          img.alt = `${g.name} header image`;
          img.src = g.header;
          header.appendChild(img);
        }

        const title = document.createElement('h3');
        title.className = 'title';
        const a = document.createElement('a');
        a.href = `https://store.steampowered.com/app/${g.app_id}`;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.textContent = g.name;
        title.appendChild(a);
        header.appendChild(title);

        const pill = document.createElement('span');
        pill.className = 'sim-pill';
        pill.title = `Matched ${item.interCount} of ${requiredCount} required tag(s) • ${label}`;
        pill.textContent = `${pct}%`;
        pill.style.borderColor = color;
        pill.style.color = color;
        header.appendChild(pill);

        card.appendChild(header);

        const devs = (g.developers && g.developers.length) ? g.developers.join(', ') : '—';
        const pubs = (g.publishers && g.publishers.length) ? g.publishers.join(', ') : '—';
        const estimate = estimateSalesUSD(g);

        const meta = document.createElement('div');
        meta.className = 'meta-row';
        meta.innerHTML = `
      <span class="meta">Developer: ${devs}</span>
      <span class="meta">Publisher: ${pubs}</span>
      <span class="meta">Released: ${g.comingSoon ? 'Coming soon' : (g.releaseFmt ?? '—')}</span>
      <span class="meta">Price: ${formatPrice(g.price)}</span>
      <span class="meta">Reviews: ${(g.reviews || 0).toLocaleString()}</span>
      <span class="meta" title="Estimated = reviews × price × 20">Estimated Sales: ${formatUSD(estimate)}</span>
    `;
        card.appendChild(meta);

        const tagsDiv = document.createElement('div');
        tagsDiv.className = 'tags';
        (g.tags || []).forEach(t => {
          const s = document.createElement('span');
          s.className = q.has(t) ? 'tag matched' : 'tag';
          s.textContent = t;
          tagsDiv.appendChild(s);
        });
        card.appendChild(tagsDiv);

        resultsEl.appendChild(card);
      }

      pageInfoEl.textContent = `Page ${currentPage} of ${totalPages}`;
      prevBtn.disabled = currentPage <= 1;
      nextBtn.disabled = currentPage >= totalPages;
      pagerEl.style.display = totalPages > 1 ? '' : (queryTags.size ? '' : 'none');
    }


    function renderQuery() {
      const hideUnreleased = !!(ignoreUnreleasedEl && ignoreUnreleasedEl.checked);

      const q = new Set(queryTags);
      if (q.size === 0) { resultsEl.innerHTML = ''; pagerEl.style.display = 'none'; return; }

      const tags = [...q];
      const lists = tags.map(t => ({ tag: t, docs: postingsFor(t) }));
      const nonEmpty = lists.filter(x => x.docs.length > 0);

      if (nonEmpty.length === 0) {
        resultsEl.innerHTML = `
          <div class="card">
            None of your query tags exist in the data.
          </div>`;
        pagerEl.style.display = 'none';
        return;
      }

      const requireAll = !!(requireAllEl && requireAllEl.checked);

      const missingTags = requireAll ? lists.filter(x => x.docs.length === 0).map(x => x.tag) : [];
      if (requireAll && missingTags.length > 0) {
        resultsEl.innerHTML = `
          <div class="card">
            No games include every query tag. Missing in data: ${missingTags.join(', ')}
          </div>`;
        pagerEl.style.display = 'none';
        requiredCount = q.size;
        return;
      }

      const requiredTags = requireAll ? new Set(tags) : new Set(nonEmpty.map(x => x.tag));
      requiredCount = requiredTags.size;

      const searchLists = requireAll ? lists : nonEmpty;

      searchLists.sort((a, b) => a.docs.length - b.docs.length);
      let candidates = searchLists[0].docs.slice();

      const union = (a, b) => {
        const out = []; let i = 0, j = 0, last = null;
        while (i < a.length || j < b.length) {
          const va = i < a.length ? a[i] : Infinity;
          const vb = j < b.length ? b[j] : Infinity;
          let v;
          if (va < vb) { v = va; i++; }
          else if (vb < va) { v = vb; j++; }
          else { v = va; i++; j++; }
          if (v !== last) { out.push(v); last = v; }
        }
        return out;
      };

      for (let i = 1; i < searchLists.length; i++) {
        candidates = requireAll
          ? intersectSorted(candidates, searchLists[i].docs)
          : union(candidates, searchLists[i].docs);
        if (requireAll && candidates.length === 0) break;
      }

      const mode = [...scoreModeEls].find(r => r.checked)?.value || 'containment';
      const results = [];

      for (const gi of candidates) {
        const g = games[gi];

        if (seedExclude && (String(g.app_id) === seedExclude.app_id || normName(g.name) === seedExclude.name)) continue;
        if (hideUnreleased && g.comingSoon) continue;

        if (releaseFilter.on && !g.comingSoon) {
          if (!(typeof g.releaseTs === 'number')) continue;
          if (g.releaseTs < releaseFilter.start) continue;
          if (g.releaseTs > releaseFilter.end) continue;
        }

        if (hasAnyBanned(g)) continue;

        // NEW: enforce any "forced" tags selected via chips
        if (forcedTags.size > 0) {
          const tagSet = buildTagSet(g);
          let ok = true;
          for (const ft of forcedTags) {
            if (!tagSet.has(ft)) {
              ok = false;
              break;
            }
          }
          if (!ok) continue; // skip games missing any forced tag
        }

        const pMin = readNum(priceMinEl), pMax = readNum(priceMaxEl);
        if (pMin !== null || pMax !== null) {
          const price = g.price;
          if (price == null) continue;
          if (pMin !== null && price < pMin) continue;
          if (pMax !== null && price > pMax) continue;
        }

        const rMin = readNum(revMinEl), rMax = readNum(revMaxEl);
        if (rMin !== null || rMax !== null) {
          const rev = estimateSalesUSD(g);
          if (!Number.isFinite(rev) || rev <= 0) continue;
          if (rMin !== null && rev < rMin) continue;
          if (rMax !== null && rev > rMax) continue;
        }

        const sc = similarityScore(g, requiredTags, mode);
        if (requireAll) {
          if (!sc.containsAll) continue;
        } else {
          if (sc.score <= 0) continue;
        }

        results.push({ gIdx: gi, score: sc.score, interCount: sc.inter });
      }


      results.sort((a, b) => {
        const ga = games[a.gIdx], gb = games[b.gIdx];
        if (b.score !== a.score) return b.score - a.score;
        const ar = ga.reviews || 0, br = gb.reviews || 0;
        if (br !== ar) return br - ar;
        const at = ga.releaseTs || 0, bt = gb.releaseTs || 0;
        if (bt !== at) return bt - at;
        const aSoon = !!ga.comingSoon, bSoon = !!gb.comingSoon;
        if (aSoon !== bSoon) return aSoon ? 1 : -1;
        return normName(ga.name).localeCompare(normName(gb.name));
      });

      const seen = new Set();
      lastResults = results.filter(r => {
        const g = games[r.gIdx];
        const key = `${normName(g.name)}::${g.comingSoon ? 'soon' : 'released'}`;
        if (seen.has(key)) return false;
        seen.add(key); return true;
      });

      totalPages = Math.max(1, Math.ceil(lastResults.length / PAGE_SIZE));
      currentPage = Math.min(currentPage, totalPages);
      renderPage();
    }

    // ---------- Seed ----------
    function parseSeedToAppId(str) {
      const s = (str || '').trim(); if (!s) return null;
      if (/^\d+$/.test(s)) return s;
      const m = s.match(/store\.steampowered\.com\/app\/(\d+)/i); if (m) return m[1];
      return null;
    }
    function findGameBySeed(seedRaw) {
      const appId = parseSeedToAppId(seedRaw);
      if (appId) { if (byAppId.has(String(appId))) return games[byAppId.get(String(appId))]; return null; }
      const nm = normName(seedRaw); if (!nm) return null;
      const arr = byName.get(nm); if (!arr || arr.length === 0) return null;
      const bestGi = arr.slice().sort((a, b) => (games[b].reviews || 0) - (games[a].reviews || 0))[0];
      return games[bestGi];
    }
    function injectTagsFromGame(g) {
      const incoming = [...(g.tags || [])];
      let added = 0;
      for (const t of incoming) {
        const nt = normTag(t);
        const before = queryTags.size; queryTags.add(nt);
        if (queryTags.size > before) added++;
      }
      return { added, total: incoming.length };
    }
    function applySeedGame(g) {
      if (!g) return;
      seedExclude = { app_id: String(g.app_id), name: normName(g.name) };
      const { added, total } = injectTagsFromGame(g);
      seedStatus.textContent = `Loaded ${added}/${total} tag(s) from “${g.name}”. (Excluded itself from results)`;
      activeSuggestIndex = -1;
      hideSuggestions();
      renderChips(); currentPage = 1; renderQuery();
    }
    function handleSeed() {
      seedStatus.textContent = '';
      const raw = seedInput.value.trim();
      if (!raw) { seedStatus.textContent = 'Enter a Steam URL, AppID, or exact game name.'; return; }
      const g = findGameBySeed(raw);
      if (!g) { seedStatus.textContent = 'That game isn’t in this list.'; return; }
      applySeedGame(g);
    }

    // ---------- Fuzzy suggestions ----------
    function shouldFuzzy(s) {
      if (!s || s.trim().length < 2) return false;
      if (parseSeedToAppId(s)) return false;
      if (/store\.steampowered\.com\/app\//i.test(s)) return false;
      return true;
    }
    function showSuggestions(items) {
      seedSuggest.innerHTML = '';
      if (!items.length) {
        seedSuggest.innerHTML = '<div class="seed-suggest-empty">No matches</div>';
      } else {
        for (let i = 0; i < items.length; i++) {
          const it = items[i];
          const row = document.createElement('div');
          row.className = 'seed-suggest-item';
          row.setAttribute('role', 'option');
          row.dataset.index = String(i);
          row.innerHTML = `
            <span class="game-name">${it.name}</span>
            <span class="meta">#${games[it.gi].app_id} · ${(games[it.gi].reviews || 0).toLocaleString()} reviews</span>
          `;
          row.addEventListener('mousedown', (e) => {
            e.preventDefault();
            seedInput.value = it.name;
            applySeedGame(games[it.gi]);
          });
          seedSuggest.appendChild(row);
        }
      }
      seedSuggest.classList.add('show');
      seedSuggest.parentElement.classList.add('suggest-open');
    }
    function hideSuggestions() {
      seedSuggest.classList.remove('show');
      seedSuggest.innerHTML = '';
      seedSuggest.parentElement.classList.remove('suggest-open');
    }
    function updateActive(idx) {
      const children = [...seedSuggest.querySelectorAll('.seed-suggest-item')];
      children.forEach(el => el.classList.remove('active'));
      if (idx >= 0 && idx < children.length) children[idx].classList.add('active');
    }
    function runFuzzy(query) {
      const qn = normName(query);
      const scored = nameIndex
        .map(it => {
          const d = fuzzyScore(qn, it);
          return { ...it, _score: d.score, _base: d.base, _substring: d.substring, _prefix: d.prefix };
        })
        .filter(it => it._base >= 0.05 || it._substring || it._prefix)
        .sort((a, b) => (b._score - a._score) || ((b.reviews || 0) - (a.reviews || 0)));
      const top = scored.slice(0, 12);
      showSuggestions(top);
      activeSuggestIndex = -1;
      updateActive(activeSuggestIndex);
    }

    seedInput.addEventListener('input', () => {
      const v = seedInput.value;
      if (shouldFuzzy(v)) runFuzzy(v);
      else hideSuggestions();
    });

    seedInput.addEventListener('keydown', (e) => {
      const open = seedSuggest.classList.contains('show');
      if (!open) {
        if (e.key === 'Enter') { e.preventDefault(); handleSeed(); }
        return;
      }
      const items = [...seedSuggest.querySelectorAll('.seed-suggest-item')];
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        activeSuggestIndex = Math.min(items.length - 1, activeSuggestIndex + 1);
        updateActive(activeSuggestIndex);
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        activeSuggestIndex = Math.max(-1, activeSuggestIndex - 1);
        updateActive(activeSuggestIndex);
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (activeSuggestIndex >= 0 && items[activeSuggestIndex]) {
          const idx = Number(items[activeSuggestIndex].dataset.index);
          const qn = normName(seedInput.value);
          const scored = nameIndex
            .map(it => { const d = fuzzyScore(qn, it); return { ...it, _score: d.score }; })
            .sort((a, b) => (b._score - a._score) || ((b.reviews || 0) - (a.reviews || 0)))
            .slice(0, 12);
          const chosen = scored[idx];
          if (chosen) {
            seedInput.value = chosen.name;
            applySeedGame(games[chosen.gi]);
          } else {
            hideSuggestions();
          }
        } else {
          handleSeed();
        }
      } else if (e.key === 'Escape') {
        hideSuggestions();
      }
    });

    document.addEventListener('click', (e) => {
      const within = e.target === seedInput || seedSuggest.contains(e.target);
      if (!within) hideSuggestions();
    });

    // ---------- Events ----------
    function parseFreeformTags(str) {
      const parts = str.split(/,/).map(s => s.trim()).filter(Boolean);
      return parts.map(p => normTag(p.replace(/^["'](.*)["']$/s, '$1')));
    }
    if (seedBtn) seedBtn.addEventListener('click', handleSeed);

    if (tagInput) tagInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        parseFreeformTags(tagInput.value).forEach(t => queryTags.add(t));
        tagInput.value = ''; currentPage = 1; renderChips(); renderQuery();
      }
    });
    addBtn.onclick = () => { parseFreeformTags(tagInput.value).forEach(t => queryTags.add(t)); tagInput.value = ''; currentPage = 1; renderChips(); renderQuery(); };
    clearBtn.onclick = () => { queryTags.clear(); currentPage = 1; renderChips(); renderQuery(); };

    if (banInput) banInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        parseFreeformTags(banInput.value).forEach(t => bannedTags.add(t));
        banInput.value = ''; currentPage = 1; renderChips(); renderQuery();
      }
    });
    banAddBtn.onclick = () => { parseFreeformTags(banInput.value).forEach(t => bannedTags.add(t)); banInput.value = ''; currentPage = 1; renderChips(); renderQuery(); };
    banClearBtn.onclick = () => { bannedTags.clear(); currentPage = 1; renderChips(); renderQuery(); };

    [...scoreModeEls].forEach(el => el.addEventListener('change', () => { currentPage = 1; renderQuery(); }));
    if (requireAllEl) requireAllEl.addEventListener('change', () => { currentPage = 1; renderQuery(); });

    prevBtn.addEventListener('click', () => { if (currentPage > 1) { currentPage--; renderPage(); } });
    nextBtn.addEventListener('click', () => { if (currentPage < totalPages) { currentPage++; renderPage(); } });

    [priceMinEl, priceMaxEl, revMinEl, revMaxEl].forEach(el => {
      if (!el) return;
      el.addEventListener('input', () => { currentPage = 1; renderQuery(); });
      el.addEventListener('change', () => { currentPage = 1; renderQuery(); });
    });

    // ---------- Load ----------
    (async () => {
      try {
        function parseRow(line) {
          const j = JSON.parse(line);
          if (j && j._meta) return null;
          const arr = v => Array.isArray(v) ? v : (v ? [v] : []);
          if (Object.prototype.hasOwnProperty.call(j, 'a')) {
            const y = (typeof j.y === 'number' && j.y > 0) ? j.y : null;
            const relTs = y != null ? Date.UTC(y, 0, 1) : null;
            return {
              app_id: j.a,
              name: j.n || `App ${j.a}`,
              tags: arr(j.t).map(t => (t ?? '').trim().toLowerCase()),
              developers: arr(j.d),
              publishers: arr(j.p),
              price: j.u ?? null,
              is_free: !!j.f,
              reviews: j.r ?? 0,
              header: j.h || null,
              releaseTs: relTs,
              releaseFmt: relTs ? fmtMonYear(relTs) : (y ? String(y) : null),
              comingSoon: !!j.cs
            };
          }

          const cls = j.classification || {};
          const id = j.identity || {};
          const media = j.media || {};
          const relRaw =
            j.release?.date_iso ??
            j.release?.date_raw ??
            id.release_date ??
            j.release_date ??
            j.meta?.release_date;

          const relTs = parseReleaseTs(relRaw);
          return {
            app_id: j.app_id,
            name: id.name || `App ${j.app_id}`,
            tags: arr(cls.tags).map(t => (t ?? '').trim().toLowerCase()),
            developers: arr(id.developers),
            publishers: arr(id.publishers),
            price: j.pricing ? j.pricing.price_usd : null,
            is_free: !!(j.pricing && j.pricing.is_free),
            reviews: (j.reviews?.review_count) ?? (j.reviews?.total_reviews) ?? 0,
            header: media.header_image || null,
            releaseTs: relTs,
            releaseFmt: relTs ? fmtMonYear(relTs) : null,
            comingSoon: !!(j.release && j.release.coming_soon)
          };
        }

        const ingestLine = (raw) => {
          const trimmed = (raw || '').trim();
          if (!trimmed) return false;
          try {
            const row = parseRow(trimmed);
            if (!row) return false;
            games.push(row);
            return true;
          } catch {
            return false;
          }
        };

        await loadJSONLStream(JSON_LINES_PATH, ingestLine);

        buildIndices();
        buildLookups();

        // Populate release selects (range) — CLAMPED TO TODAY
        const TODAY = new Date();
        const CUR_YEAR = TODAY.getUTCFullYear();
        const CUR_MONTH = TODAY.getUTCMonth();

        const yearsInData = games
          .map(g => g.releaseTs)
          .filter(Boolean)
          .map(ts => new Date(ts).getUTCFullYear());

        let minYear = yearsInData.length ? Math.min(...yearsInData) : 1997;
        let dataMax = yearsInData.length ? Math.max(...yearsInData) : CUR_YEAR;
        const maxYear = Math.min(dataMax, CUR_YEAR); // hard clamp at current year

        // safety fallback if data is weird/future-only
        if (!Number.isFinite(minYear) || minYear > maxYear) minYear = Math.max(1997, CUR_YEAR - 30);

        function fillMonth(sel) {
          sel.innerHTML = MONTHS.map((m, i) => `<option value="${i}">${m}</option>`).join('');
        }
        function fillYear(sel) {
          let yOpts = '';
          for (let y = maxYear; y >= minYear; y--) yOpts += `<option value="${y}">${y}</option>`;
          sel.innerHTML = yOpts;
        }

        fillMonth(relStartMonth); fillMonth(relEndMonth);
        fillYear(relStartYear); fillYear(relEndYear);

        // Default: start at earliest year, end at TODAY (clamped)
        relStartMonth.value = '0';
        relStartYear.value = String(minYear);
        relEndMonth.value = String(CUR_MONTH);
        relEndYear.value = String(CUR_YEAR);


        function updateRange() {
          let sy = +relStartYear.value, sm = +relStartMonth.value;
          let ey = +relEndYear.value, em = +relEndMonth.value;

          // hard clamp end to <= today
          if (ey > CUR_YEAR) { ey = CUR_YEAR; relEndYear.value = String(CUR_YEAR); }
          if (ey === CUR_YEAR && em > CUR_MONTH) { em = CUR_MONTH; relEndMonth.value = String(CUR_MONTH); }

          // keep start within [minYear, ey]
          if (sy < minYear) { sy = minYear; relStartYear.value = String(minYear); }
          if (sy > ey) { sy = ey; relStartYear.value = String(ey); }
          if (sy === ey && sm > em) { sm = em; relStartMonth.value = String(em); }

          releaseFilter.sy = sy; releaseFilter.sm = sm;
          releaseFilter.ey = ey; releaseFilter.em = em;
          releaseFilter.start = firstOfMonthUTC(sy, sm);
          releaseFilter.end = lastOfMonthUTC(ey, em);

          currentPage = 1; renderQuery();
        }


        function toggleRange() {
          releaseFilter.on = !!releaseRangeOn.checked;
          currentPage = 1; renderQuery();
        }

        releaseRangeOn.addEventListener('change', toggleRange);
        relStartMonth.addEventListener('change', updateRange);
        relStartYear.addEventListener('change', updateRange);
        relEndMonth.addEventListener('change', updateRange);
        relEndYear.addEventListener('change', updateRange);

        if (ignoreUnreleasedEl) {
          ignoreUnreleasedEl.addEventListener('change', () => { currentPage = 1; renderQuery(); });
        }

      } catch (err) {
        resultsEl.innerHTML = `<div class="card">${err.message}</div>`;
        return;
      } finally {
        hideLoader();
      }
      renderChips();
    })();
  </script>
</body>

</html>



